{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to PyArud (\u0628\u064a\u0639\u0631\u0648\u0636)","text":"<p>PyArud is the definitive Python library for Arabic prosody (Arud) analysis. It bridges the gap between classical prosodic theory and modern computational linguistics.</p> <p>Whether you are a developer building a poetry app, a researcher analyzing classical corpuses, or a student of Ilm al-Arudh, PyArud provides the tools you need.</p>   -   :material-book-open-variant: **Deep Theory**     Learn the science of Arudh, from Al-Khalil's circles to the anatomy of a Watad.     [:arrow_right: Read the Theory](theory/introduction.md)  -   :material-scale-balance: **The 16 Meters**     A comprehensive reference for every Bahr, its keys, variations, and allowed modifications.     [:arrow_right: Explore Meters](meters.md)  -   :material-code-json: **Robust Analysis**     Detect meters, analyze feet, and identify specific defects (Zihaf &amp; Ellah) with precision.     [:arrow_right: Quick Start](quickstart.md)  -   :material-hammer-wrench: **Extensible Architecture**     Built on a modular pipeline that allows you to register custom spellings and extend definitions.     [:arrow_right: Architecture](architecture.md)"},{"location":"#why-pyarud","title":"Why PyArud?","text":"<p>Arabic prosody is not just about counting syllables. It is a complex system of permissibility (<code>Jawaz</code>) and necessity (<code>Wujub</code>).</p> <p>PyArud is different because: 1.  It knows the rules: It doesn't just regex match. It understands that a <code>Mustaf'ilun</code> in Rajaz allows different changes than a <code>Mustaf'ilun</code> in Basit. 2.  It handles the details: From <code>Iltiqa al-Sakinayn</code> (meeting of stills) to <code>Ashba'</code> (saturation), the linguistic engine handles the nuances of Arabic phonetics. 3.  It speaks the language: The documentation and code use the correct Arabic terminology (Sabab, Watad, Arudh, Dharb) mapped to English, making it a learning resource in itself.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install pyarud\n</code></pre>"},{"location":"#example-analysis","title":"Example Analysis","text":"<pre><code>from pyarud.processor import ArudhProcessor\n\n# A verse from Al-Mutanabbi\nverse = [(\"\u0623\u064e\u0644\u0627 \u0644\u0627 \u0623\u064f\u0631\u064a \u0627\u0644\u0623\u062d\u0652\u062f\u0627\u062b\u064e \u062d\u064e\u0645\u0652\u062f\u064b\u0627 \u0648\u064e\u0644\u0627 \u0630\u064e\u0645\u0651\u0627\", \"\u0641\u064e\u0645\u0627 \u0628\u064e\u0637\u0652\u0634\u064f\u0647\u0627 \u062c\u064e\u0647\u0652\u0644\u064b\u0627 \u0648\u064e\u0644\u0627 \u0643\u064e\u0641\u064f\u0651\u0647\u0627 \u062d\u0650\u0644\u0652\u0645\u0627\")]\n\nprocessor = ArudhProcessor()\nresult = processor.process_poem(verse)\n\nprint(f\"Meter: {result['meter']}\") # 'taweel'\nprint(f\"Score: {result['verses'][0]['score']}\")\n</code></pre>"},{"location":"api/","title":"API Reference","text":"<p>This reference is automatically generated from the source code docstrings.</p>"},{"location":"api/#arudh-processor","title":"Arudh Processor","text":""},{"location":"api/#pyarud.processor.ArudhProcessor","title":"<code>pyarud.processor.ArudhProcessor</code>","text":"<p>The main engine for Arabic prosody analysis.</p> <p>This class handles: 1. Converting Arabic text to Arudi writing (phonetic representation). 2. Converting Arudi text to binary patterns (1s and 0s). 3. Detecting the poetic meter (Bahr) from a list of meters. 4. Performing granular, foot-by-foot analysis to identify defects (Zihaf/Ellah).</p> Source code in <code>pyarud/processor.py</code> <pre><code>class ArudhProcessor:\n    \"\"\"\n    The main engine for Arabic prosody analysis.\n\n    This class handles:\n    1. Converting Arabic text to Arudi writing (phonetic representation).\n    2. Converting Arudi text to binary patterns (1s and 0s).\n    3. Detecting the poetic meter (Bahr) from a list of meters.\n    4. Performing granular, foot-by-foot analysis to identify defects (Zihaf/Ellah).\n    \"\"\"\n    def __init__(self):\n        self.converter = ArudiConverter()\n        self.meter_classes = get_all_meters()\n        self.precomputed_patterns = {}\n        self._precompute_patterns()\n\n    def _precompute_patterns(self):\n        \"\"\"\n        Generates structured valid patterns for each meter using the detailed_patterns engine.\n        \"\"\"\n        for name, bahr_cls in self.meter_classes.items():\n            bahr_instance = bahr_cls()\n            # detailed_patterns returns {'sadr': [...], 'ajuz': [...], 'pairs': set()}\n            self.precomputed_patterns[name] = bahr_instance.detailed_patterns\n\n    def _get_similarity(self, a, b):\n        # Use cubic scaling to penalize small mismatches more heavily.\n        # A 0.95 raw ratio becomes ~0.73, increasing separation significantly.\n        return math.pow(SequenceMatcher(None, a, b).ratio(), 6)\n\n    def process_poem(self, verses, meter_name=None):\n        \"\"\"\n        Analyzes a list of verses to detect the meter and evaluate prosodic correctness.\n\n        Args:\n            verses (list[tuple[str, str]]): A list of tuples, where each tuple contains\n                the Sadr (first hemistich) and Ajuz (second hemistich) of a verse.\n            meter_name (str, optional): The name of a specific meter to force the analysis against.\n                If provided, auto-detection is skipped. Defaults to None.\n\n        Returns:\n            dict: A dictionary containing:\n                - `meter` (str): The name of the detected or forced meter.\n                - `verses` (list[dict]): A list of analysis results for each verse, including:\n                    - `score` (float): Compatibility score (0.0 - 1.0).\n                    - `sadr_analysis` (list[dict]): Detailed foot-by-foot analysis of the Sadr.\n                    - `ajuz_analysis` (list[dict]): Detailed foot-by-foot analysis of the Ajuz.\n        \"\"\"\n        detected_counts = Counter()\n        temp_results = []\n\n        # 1. Detect Meter for each verse (if not forced)\n        for i, (sadr, ajuz) in enumerate(verses):\n            # Convert text to pattern\n            # Generate candidates for Sadr: Saturated (Standard) and Unsaturated (Mudawwar/Fragment)\n            sadr_res_sat = self.converter.prepare_text(sadr, saturate=True)\n            sadr_res_unsat = self.converter.prepare_text(sadr, saturate=False)\n\n            # Generate candidates for Ajuz: Saturated (Mutlaq) and Unsaturated (Muqayyad)\n            ajuz_res_sat = self.converter.prepare_text(ajuz, saturate=True)\n            ajuz_res_unsat = self.converter.prepare_text(ajuz, saturate=False, muqayyad=True)\n\n            # Handle single shatr input if needed (future proofing)\n            if not ajuz:\n                ajuz_res_sat = (\"\", \"\")\n                ajuz_res_unsat = (\"\", \"\")\n\n            match_info = None\n\n            # Collect candidates: [(arudi_text, pattern), ...]\n            sadr_candidates = [sadr_res_sat]\n            if sadr_res_unsat[1] != sadr_res_sat[1]:\n                sadr_candidates.append(sadr_res_unsat)\n\n            ajuz_candidates = [ajuz_res_sat]\n            if ajuz_res_unsat[1] != ajuz_res_sat[1]:\n                ajuz_candidates.append(ajuz_res_unsat)\n\n            # Find best meter (or best fit for forced meter)\n            candidates = self._find_best_meter(sadr_candidates, ajuz_candidates, target_meter=meter_name)\n            if candidates:\n                best_match = candidates[0]\n                detected_counts[best_match[\"meter\"]] += 1\n                match_info = best_match\n\n            # Determine which candidates won\n            chosen_sadr = sadr_candidates[0] # Default\n            chosen_ajuz = ajuz_candidates[0] # Default\n\n            if match_info:\n                if \"sadr_input_pattern\" in match_info:\n                     for cand in sadr_candidates:\n                         if cand[1] == match_info[\"sadr_input_pattern\"]:\n                             chosen_sadr = cand\n                             break\n                if \"ajuz_input_pattern\" in match_info:\n                     for cand in ajuz_candidates:\n                         if cand[1] == match_info[\"ajuz_input_pattern\"]:\n                             chosen_ajuz = cand\n                             break\n\n            temp_results.append(\n                {\n                    \"index\": i,\n                    \"sadr\": {\"text\": sadr, \"pattern\": chosen_sadr[1], \"arudi\": chosen_sadr[0]},\n                    \"ajuz\": {\"text\": ajuz, \"pattern\": chosen_ajuz[1], \"arudi\": chosen_ajuz[0]},\n                    \"match\": match_info,\n                }\n            )\n\n        if meter_name:\n            global_meter = meter_name\n        elif detected_counts:\n            global_meter = detected_counts.most_common(1)[0][0]\n        else:\n            return {\"error\": \"Could not detect any valid meter.\"}\n\n        # 2. Analyze against Global Meter\n        final_analysis = []\n        for res in temp_results:\n            analysis = self._analyze_verse(res, global_meter)\n            final_analysis.append(analysis)\n\n        return {\"meter\": global_meter, \"verses\": final_analysis}\n\n    def _find_best_meter(self, sadr_candidates, ajuz_candidates, target_meter=None):\n        METER_PRIORITY = {\n            \"rajaz\": 20,\n            \"kamel\": 10,\n            \"hazaj\": 20,\n            \"wafer\": 10,\n            \"saree\": 20,\n            \"munsareh\": 10,\n            \"baseet\": 10,\n            \"ramal\": 15,\n            \"mutadarak\": 15,\n            \"mutakareb\": 15,\n        }\n\n        candidates = []\n\n        meters_to_check = self.precomputed_patterns.items()\n        if target_meter:\n            if target_meter in self.precomputed_patterns:\n                meters_to_check = [(target_meter, self.precomputed_patterns[target_meter])]\n            else:\n                return []\n\n        for name, patterns in meters_to_check:\n            # 1. Score Sadr candidates and pick best for this meter\n            best_sadr = None\n            best_sadr_score = -1\n            best_sadr_input = \"\"\n\n            for cand in sadr_candidates:\n                cand_pat = cand[1]\n                match = self._find_best_component_match(cand_pat, patterns[\"sadr\"])\n                if match[\"score\"] &gt; best_sadr_score:\n                    best_sadr_score = match[\"score\"]\n                    best_sadr = match\n                    best_sadr_input = cand_pat\n\n            # 2. Score Ajuz candidates (if exists)\n            best_ajuz = None\n            best_ajuz_score = -1\n            best_ajuz_input = \"\"\n\n            has_ajuz = any(c[1] for c in ajuz_candidates)\n\n            if has_ajuz:\n                for cand in ajuz_candidates:\n                    cand_pat = cand[1]\n                    if not cand_pat:\n                        continue\n                    match = self._find_best_component_match(cand_pat, patterns[\"ajuz\"])\n                    if match[\"score\"] &gt; best_ajuz_score:\n                        best_ajuz_score = match[\"score\"]\n                        best_ajuz = match\n                        best_ajuz_input = cand_pat\n\n            # 3. Calculate Combined Score\n            s_score = best_sadr_score\n            a_score = best_ajuz_score if best_ajuz else 0\n\n            # Compatibility Check\n            is_valid_pair = False\n            if best_sadr and best_sadr[\"ref\"] and (not has_ajuz or (best_ajuz and best_ajuz[\"ref\"])):\n                s_pat = best_sadr[\"ref\"][\"pattern\"]\n                a_pat = best_ajuz[\"ref\"][\"pattern\"] if best_ajuz else \"\"\n                if (s_pat, a_pat) in patterns[\"pairs\"]:\n                    is_valid_pair = True\n\n            if has_ajuz:\n                total_score = (s_score + a_score) / 2\n            else:\n                total_score = s_score\n\n            candidates.append({\n                \"meter\": name,\n                \"score\": total_score,\n                \"sadr_match\": best_sadr,\n                \"ajuz_match\": best_ajuz,\n                \"valid_pair\": is_valid_pair,\n                \"sadr_input_pattern\": best_sadr_input,\n                \"ajuz_input_pattern\": best_ajuz_input\n            })\n\n        # Sort candidates\n        candidates.sort(key=lambda x: (\n            round(x[\"score\"], 3),\n            x[\"valid_pair\"],\n            METER_PRIORITY.get(x[\"meter\"], 0)\n        ), reverse=True)\n\n        if not candidates:\n            return []\n\n        return candidates\n\n    def _find_best_component_match(self, input_pattern, component_patterns):\n        best_score = -1\n        best_ref = None\n\n        for item in component_patterns:\n            ref_pat = item[\"pattern\"]\n            score = self._get_similarity(ref_pat, input_pattern)\n            if score &gt; best_score:\n                best_score = score\n                best_ref = item\n\n        return {\"score\": best_score, \"ref\": best_ref}\n\n    def _analyze_verse(self, res, meter_name):\n        # Re-run match against specific meter to get details\n        patterns = self.precomputed_patterns.get(meter_name)\n        if not patterns:\n            return {\"error\": \"Meter data not found\"}\n\n        sadr_match = self._find_best_component_match(res[\"sadr\"][\"pattern\"], patterns[\"sadr\"])\n        ajuz_match = None\n        if res[\"ajuz\"][\"pattern\"]:\n            ajuz_match = self._find_best_component_match(res[\"ajuz\"][\"pattern\"], patterns[\"ajuz\"])\n\n        # Get allowed feet for this meter for greedy analysis\n        bahr_cls = self.meter_classes.get(meter_name)\n        allowed_sadr = []\n        allowed_ajuz = []\n        if bahr_cls:\n            inst = bahr_cls()\n            allowed_sadr = inst.get_allowed_feet_patterns(0)\n            allowed_ajuz = inst.get_allowed_feet_patterns(1)\n\n        # Analyze Sadr Feet\n        sadr_analysis = self._analyze_feet(res[\"sadr\"][\"pattern\"], allowed_sadr, sadr_match[\"ref\"])\n\n        ajuz_analysis = None\n        if res[\"ajuz\"][\"pattern\"]:\n            ajuz_analysis = self._analyze_feet(res[\"ajuz\"][\"pattern\"], allowed_ajuz, ajuz_match[\"ref\"])\n\n        return {\n            \"verse_index\": res[\"index\"],\n            \"sadr_text\": res[\"sadr\"][\"text\"],\n            \"ajuz_text\": res[\"ajuz\"][\"text\"],\n            \"input_pattern\": res[\"sadr\"][\"pattern\"] + res[\"ajuz\"][\"pattern\"],\n            \"best_ref_pattern\": (sadr_match[\"ref\"][\"pattern\"] if sadr_match[\"ref\"] else \"\") + \n                                (ajuz_match[\"ref\"][\"pattern\"] if ajuz_match and ajuz_match[\"ref\"] else \"\"),\n            \"score\": round(\n                (sadr_match[\"score\"] + (ajuz_match[\"score\"] if ajuz_match else 0)) / (2 if ajuz_match else 1), 2\n            ),\n            \"sadr_analysis\": sadr_analysis,\n            \"ajuz_analysis\": ajuz_analysis\n        }\n\n    def _analyze_feet(self, input_pattern, allowed_feet_list, best_ref):\n        \"\"\"\n        Maps input bits to feet using greedy matching against ALLOWED forms.\n        This prevents one broken foot from misaligning the rest if they are valid.\n        \"\"\"\n        analysis = []\n        current_idx = 0\n\n        # Fallback to best_ref feet if allowed_feet_list is not provided (should not happen)\n        ref_feet_backup = best_ref[\"feet\"] if best_ref else []\n\n        # Determine number of feet to analyze\n        num_feet = len(allowed_feet_list) if allowed_feet_list else len(ref_feet_backup)\n\n        for i in range(num_feet):\n            # 1. Get valid candidates for this foot position\n            if allowed_feet_list:\n                candidates = allowed_feet_list[i]\n            elif i &lt; len(ref_feet_backup):\n                candidates = [ref_feet_backup[i]]\n            else:\n                candidates = []\n\n            # Sort candidates by length descending to try longest match first\n            candidates = sorted(candidates, key=len, reverse=True)\n\n            best_local_match = None\n            best_local_score = -1\n\n            # Try to find best fit at current_idx\n            # We look ahead by len(cand)\n            for cand in candidates:\n                cand_len = len(cand)\n                # Get segment of equal length (or truncated if at end)\n                segment = input_pattern[current_idx : current_idx + cand_len]\n\n                if not segment:\n                    break  # No more input\n\n                score = self._get_similarity(cand, segment)\n\n                # Boost score if lengths match (to prefer aligning valid feet)\n                if len(segment) == cand_len:\n                    if score == 1.0:\n                        # Found perfect match, take it immediately\n                        best_local_match = cand\n                        best_local_score = 1.0\n                        break\n\n                if score &gt; best_local_score:\n                    best_local_score = score\n                    best_local_match = cand\n                    # Consume what we compared against\n\n            # If no candidates (e.g., error in definitions), break\n            if not best_local_match and candidates:\n                best_local_match = candidates[0] # Default to first/longest\n\n            # If we still didn't find anything (e.g. input exhausted), skip\n            if not best_local_match:\n                analysis.append({\n                    \"foot_index\": i,\n                    \"expected_pattern\": candidates[0] if candidates else \"?\",\n                    \"actual_segment\": \"MISSING\",\n                    \"score\": 0.0,\n                    \"status\": \"missing\"\n                })\n                continue\n\n            # Extract the segment we decided to consume\n            # Logic: If score is low, we should consume the length of the EXPECTED pattern \n            # to keep alignment for next feet? Or length of actual?\n            # If we assume the user *tried* to write the pattern, we consume Pattern Length.\n\n            consume_len = len(best_local_match)\n            # Clamp to input length\n            end_idx = min(current_idx + consume_len, len(input_pattern))\n            actual_segment = input_pattern[current_idx : end_idx]\n\n            # Recalculate score on the final decided segment\n            final_score = self._get_similarity(best_local_match, actual_segment)\n\n            status = \"ok\" if final_score == 1.0 else \"broken\"\n            if not actual_segment:\n                status = \"missing\"\n\n            analysis.append({\n                \"foot_index\": i,\n                \"expected_pattern\": best_local_match,\n                \"actual_segment\": actual_segment,\n                \"score\": round(final_score, 2),\n                \"status\": status\n            })\n\n            current_idx = end_idx\n\n        # Check for extra bits\n        if current_idx &lt; len(input_pattern):\n            extra = input_pattern[current_idx:]\n            analysis.append({\n                \"foot_index\": num_feet,\n                \"expected_pattern\": \"\",\n                \"actual_segment\": extra,\n                \"score\": 0,\n                \"status\": \"extra_bits\"\n            })\n\n        return analysis\n</code></pre>"},{"location":"api/#pyarud.processor.ArudhProcessor.process_poem","title":"<code>process_poem(verses, meter_name=None)</code>","text":"<p>Analyzes a list of verses to detect the meter and evaluate prosodic correctness.</p> <p>Parameters:</p> Name Type Description Default <code>verses</code> <code>list[tuple[str, str]]</code> <p>A list of tuples, where each tuple contains the Sadr (first hemistich) and Ajuz (second hemistich) of a verse.</p> required <code>meter_name</code> <code>str</code> <p>The name of a specific meter to force the analysis against. If provided, auto-detection is skipped. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing: - <code>meter</code> (str): The name of the detected or forced meter. - <code>verses</code> (list[dict]): A list of analysis results for each verse, including:     - <code>score</code> (float): Compatibility score (0.0 - 1.0).     - <code>sadr_analysis</code> (list[dict]): Detailed foot-by-foot analysis of the Sadr.     - <code>ajuz_analysis</code> (list[dict]): Detailed foot-by-foot analysis of the Ajuz.</p> Source code in <code>pyarud/processor.py</code> <pre><code>def process_poem(self, verses, meter_name=None):\n    \"\"\"\n    Analyzes a list of verses to detect the meter and evaluate prosodic correctness.\n\n    Args:\n        verses (list[tuple[str, str]]): A list of tuples, where each tuple contains\n            the Sadr (first hemistich) and Ajuz (second hemistich) of a verse.\n        meter_name (str, optional): The name of a specific meter to force the analysis against.\n            If provided, auto-detection is skipped. Defaults to None.\n\n    Returns:\n        dict: A dictionary containing:\n            - `meter` (str): The name of the detected or forced meter.\n            - `verses` (list[dict]): A list of analysis results for each verse, including:\n                - `score` (float): Compatibility score (0.0 - 1.0).\n                - `sadr_analysis` (list[dict]): Detailed foot-by-foot analysis of the Sadr.\n                - `ajuz_analysis` (list[dict]): Detailed foot-by-foot analysis of the Ajuz.\n    \"\"\"\n    detected_counts = Counter()\n    temp_results = []\n\n    # 1. Detect Meter for each verse (if not forced)\n    for i, (sadr, ajuz) in enumerate(verses):\n        # Convert text to pattern\n        # Generate candidates for Sadr: Saturated (Standard) and Unsaturated (Mudawwar/Fragment)\n        sadr_res_sat = self.converter.prepare_text(sadr, saturate=True)\n        sadr_res_unsat = self.converter.prepare_text(sadr, saturate=False)\n\n        # Generate candidates for Ajuz: Saturated (Mutlaq) and Unsaturated (Muqayyad)\n        ajuz_res_sat = self.converter.prepare_text(ajuz, saturate=True)\n        ajuz_res_unsat = self.converter.prepare_text(ajuz, saturate=False, muqayyad=True)\n\n        # Handle single shatr input if needed (future proofing)\n        if not ajuz:\n            ajuz_res_sat = (\"\", \"\")\n            ajuz_res_unsat = (\"\", \"\")\n\n        match_info = None\n\n        # Collect candidates: [(arudi_text, pattern), ...]\n        sadr_candidates = [sadr_res_sat]\n        if sadr_res_unsat[1] != sadr_res_sat[1]:\n            sadr_candidates.append(sadr_res_unsat)\n\n        ajuz_candidates = [ajuz_res_sat]\n        if ajuz_res_unsat[1] != ajuz_res_sat[1]:\n            ajuz_candidates.append(ajuz_res_unsat)\n\n        # Find best meter (or best fit for forced meter)\n        candidates = self._find_best_meter(sadr_candidates, ajuz_candidates, target_meter=meter_name)\n        if candidates:\n            best_match = candidates[0]\n            detected_counts[best_match[\"meter\"]] += 1\n            match_info = best_match\n\n        # Determine which candidates won\n        chosen_sadr = sadr_candidates[0] # Default\n        chosen_ajuz = ajuz_candidates[0] # Default\n\n        if match_info:\n            if \"sadr_input_pattern\" in match_info:\n                 for cand in sadr_candidates:\n                     if cand[1] == match_info[\"sadr_input_pattern\"]:\n                         chosen_sadr = cand\n                         break\n            if \"ajuz_input_pattern\" in match_info:\n                 for cand in ajuz_candidates:\n                     if cand[1] == match_info[\"ajuz_input_pattern\"]:\n                         chosen_ajuz = cand\n                         break\n\n        temp_results.append(\n            {\n                \"index\": i,\n                \"sadr\": {\"text\": sadr, \"pattern\": chosen_sadr[1], \"arudi\": chosen_sadr[0]},\n                \"ajuz\": {\"text\": ajuz, \"pattern\": chosen_ajuz[1], \"arudi\": chosen_ajuz[0]},\n                \"match\": match_info,\n            }\n        )\n\n    if meter_name:\n        global_meter = meter_name\n    elif detected_counts:\n        global_meter = detected_counts.most_common(1)[0][0]\n    else:\n        return {\"error\": \"Could not detect any valid meter.\"}\n\n    # 2. Analyze against Global Meter\n    final_analysis = []\n    for res in temp_results:\n        analysis = self._analyze_verse(res, global_meter)\n        final_analysis.append(analysis)\n\n    return {\"meter\": global_meter, \"verses\": final_analysis}\n</code></pre>"},{"location":"api/#bahr-meters","title":"Bahr (Meters)","text":""},{"location":"api/#pyarud.bahr.Bahr","title":"<code>pyarud.bahr.Bahr</code>","text":"<p>Base class for defining poetic meters (Buhur).</p> <p>Subclasses define the standard feet (tafeelat), valid Arudh/Dharb combinations, and disallowed variations (Zihaf) for specific positions.</p> Source code in <code>pyarud/bahr.py</code> <pre><code>class Bahr:\n    \"\"\"\n    Base class for defining poetic meters (Buhur).\n\n    Subclasses define the standard feet (tafeelat), valid Arudh/Dharb combinations,\n    and disallowed variations (Zihaf) for specific positions.\n    \"\"\"\n    tafeelat: tuple[type[Tafeela], ...] = ()\n    arod_dharbs_map: dict[type[BaseEllahZehaf], tuple[type[BaseEllahZehaf], ...]] | set[type[BaseEllahZehaf]] = {}\n    sub_bahrs: tuple[type[\"Bahr\"], ...] = ()\n    only_one_shatr = False\n    disallowed_zehafs_for_hashw: dict[int, tuple[list[type[BaseEllahZehaf]], ...]] = {}\n\n    @property\n    def last_tafeela(self):\n        return self.tafeelat[-1]()\n\n    def get_shatr_hashw_combinations(self, shatr_index=0):\n        combinations = []\n        # Hashw is everything except the last tafeela (Arudh/Dharb)\n        for i, tafeela_class in enumerate(self.tafeelat[:-1]):\n            tafeela = tafeela_class()\n            forms = tafeela.all_zehaf_tafeela_forms()\n\n            # Filter disallowed zehafs\n            if shatr_index in self.disallowed_zehafs_for_hashw:\n                disallowed = self.disallowed_zehafs_for_hashw[shatr_index]\n                if i &lt; len(disallowed):\n                    forms = [f for f in forms if f.applied_ella_zehaf_class not in disallowed[i]]\n\n            combinations.append(forms)\n        return combinations\n\n    def get_allowed_feet_patterns(self, shatr_index=0):\n        \"\"\"\n        Returns a list of lists, where index i contains all valid binary strings for foot i.\n        Used for granular analysis to align input to valid feet.\n        \"\"\"\n        allowed_per_index = []\n\n        # Hashw feet\n        hashw_combs = self.get_shatr_hashw_combinations(shatr_index)\n        for _, forms in enumerate(hashw_combs):\n            allowed_per_index.append([str(f) for f in forms])\n\n        # Last foot (Arudh/Dharb)\n        last_feet = set()\n        if self.only_one_shatr:\n            # Treat endings as Arudh\n            if isinstance(self.arod_dharbs_map, set):\n                for z_cls in self.arod_dharbs_map:\n                    try:\n                        last_feet.add(str(z_cls(self.last_tafeela).modified_tafeela))\n                    except AssertionError:\n                        continue\n            else:\n                for z_cls in self.arod_dharbs_map:\n                    try:\n                        last_feet.add(str(z_cls(self.last_tafeela).modified_tafeela))\n                    except AssertionError:\n                        continue\n        else:\n            if shatr_index == 0:  # Sadr -&gt; Arudh\n                for z_cls in self.arod_dharbs_map.keys():\n                    try:\n                        last_feet.add(str(z_cls(self.last_tafeela).modified_tafeela))\n                    except AssertionError:\n                        continue\n            else:  # Ajuz -&gt; Dharb\n                for d_list in self.arod_dharbs_map.values():\n                    for z_cls in d_list:\n                        try:\n                            last_feet.add(str(z_cls(self.last_tafeela).modified_tafeela))\n                        except AssertionError:\n                            continue\n\n        allowed_per_index.append(list(last_feet))\n        return allowed_per_index\n\n    @property\n    def detailed_patterns(self):\n        \"\"\"\n        Returns structured patterns for Sadr and Ajuz separately.\n        \"\"\"\n        patterns = {\n            \"sadr\": [],\n            \"ajuz\": [],\n            \"pairs\": set() # Set of (sadr_pattern_str, ajuz_pattern_str) for validation\n        }\n\n        if self.only_one_shatr:\n             # Single shatr meters (Mashtoor/Manhook)\n             # We treat them as Sadr only\n             hashw = self.get_shatr_hashw_combinations()\n\n             # For single shatr, the \"Arudh\" is the end of the line\n\n             # Collect all allowed endings from the map\n             # In single shatr, arod_dharbs_map is a set or dict. \n             # If dict, keys are allowed endings? Or values?\n             # Looking at subclasses: arod_dharbs_map = {Waqf, Kasf} (Set)\n\n             endings = []\n             if isinstance(self.arod_dharbs_map, set):\n                 for z_cls in self.arod_dharbs_map:\n                     try:\n                         endings.append(z_cls(self.last_tafeela).modified_tafeela)\n                     except AssertionError:\n                         continue\n             else:\n                 # If it's a dict (some Mashtoors might use dict?), iterate keys\n                 for z_cls in self.arod_dharbs_map:\n                     try:\n                         endings.append(z_cls(self.last_tafeela).modified_tafeela)\n                     except AssertionError:\n                         continue\n\n             permutations = list(itertools.product(*hashw, endings))\n             for p in permutations:\n                 # p is a tuple of Tafeela objects\n                 feet_strs = [str(t) for t in p]\n                 full_str = \"\".join(feet_strs)\n                 patterns[\"sadr\"].append({\n                     \"pattern\": full_str,\n                     \"feet\": feet_strs,\n                     \"type\": \"single_shatr\"\n                 })\n                 # Pairs logic doesn't apply or is trivial\n                 patterns[\"pairs\"].add((full_str, \"\"))\n\n        else:\n            # Two shatrs\n            sadr_hashw = self.get_shatr_hashw_combinations(0)\n            ajuz_hashw = self.get_shatr_hashw_combinations(1)\n\n            for arudh_z_cls, dharb_z_list in self.arod_dharbs_map.items():\n                # 1. Generate Arudh (End of Sadr)\n                try:\n                    arudh_obj = arudh_z_cls(self.last_tafeela).modified_tafeela\n                except AssertionError:\n                    continue\n\n                arudh_str = str(arudh_obj)\n\n                # 2. Generate Sadr variations for this Arudh\n                sadr_perms = list(itertools.product(*sadr_hashw, [arudh_obj]))\n\n                for sp in sadr_perms:\n                    feet_strs = [str(t) for t in sp]\n                    full_sadr = \"\".join(feet_strs)\n\n                    patterns[\"sadr\"].append({\n                        \"pattern\": full_sadr,\n                        \"feet\": feet_strs,\n                        \"arudh_foot\": arudh_str,\n                        \"arudh_class\": arudh_z_cls.__name__\n                    })\n\n                    # 3. Generate compatible Dharbs (End of Ajuz)\n                    # dharb_z_list is tuple of allowed classes for this Arudh\n                    compatible_dharbs = []\n                    for d_z in dharb_z_list:\n                        try:\n                            dharb_obj = d_z(self.last_tafeela).modified_tafeela\n                            compatible_dharbs.append(dharb_obj)\n                        except AssertionError:\n                            continue\n\n                    if not compatible_dharbs:\n                        continue\n\n                    # 4. Generate Ajuz variations for these Dharbs\n                    ajuz_perms = list(itertools.product(*ajuz_hashw, compatible_dharbs))\n\n                    for ap in ajuz_perms:\n                        feet_strs_a = [str(t) for t in ap]\n                        full_ajuz = \"\".join(feet_strs_a)\n\n                        patterns[\"ajuz\"].append({\n                            \"pattern\": full_ajuz,\n                            \"feet\": feet_strs_a,\n                            \"dharb_foot\": feet_strs_a[-1],\n                            \"allowed_arudhs\": [arudh_str] # Valid only if Sadr ended with this\n                        })\n\n                        # Register valid pair\n                        patterns[\"pairs\"].add((full_sadr, full_ajuz))\n\n        # Deduplicate lists (dicts are not hashable, use careful logic or just return list)\n        # Actually, we generated duplicates if multiple Arudh classes result in same pattern?\n        # It's fine for now. The Processor will handle matching.\n\n        # Add sub-bahrs\n        for sub in self.sub_bahrs:\n            sub_p = sub().detailed_patterns\n            patterns[\"sadr\"].extend(sub_p[\"sadr\"])\n            patterns[\"ajuz\"].extend(sub_p[\"ajuz\"])\n            patterns[\"pairs\"].update(sub_p[\"pairs\"])\n\n        return patterns\n\n    @property\n    def bait_combinations(self):\n        # Deprecated wrapper for backward compatibility\n        # Returns flattened list of full lines\n        p = self.detailed_patterns\n        if self.only_one_shatr:\n            return sorted(list(set(x[\"pattern\"] for x in p[\"sadr\"])), key=len)\n\n        # Reconstruct full lines from pairs\n        return sorted([s+a for s,a in p[\"pairs\"]], key=len)\n</code></pre>"},{"location":"api/#pyarud.bahr.Bahr.detailed_patterns","title":"<code>detailed_patterns</code>  <code>property</code>","text":"<p>Returns structured patterns for Sadr and Ajuz separately.</p>"},{"location":"api/#pyarud.bahr.Bahr.get_allowed_feet_patterns","title":"<code>get_allowed_feet_patterns(shatr_index=0)</code>","text":"<p>Returns a list of lists, where index i contains all valid binary strings for foot i. Used for granular analysis to align input to valid feet.</p> Source code in <code>pyarud/bahr.py</code> <pre><code>def get_allowed_feet_patterns(self, shatr_index=0):\n    \"\"\"\n    Returns a list of lists, where index i contains all valid binary strings for foot i.\n    Used for granular analysis to align input to valid feet.\n    \"\"\"\n    allowed_per_index = []\n\n    # Hashw feet\n    hashw_combs = self.get_shatr_hashw_combinations(shatr_index)\n    for _, forms in enumerate(hashw_combs):\n        allowed_per_index.append([str(f) for f in forms])\n\n    # Last foot (Arudh/Dharb)\n    last_feet = set()\n    if self.only_one_shatr:\n        # Treat endings as Arudh\n        if isinstance(self.arod_dharbs_map, set):\n            for z_cls in self.arod_dharbs_map:\n                try:\n                    last_feet.add(str(z_cls(self.last_tafeela).modified_tafeela))\n                except AssertionError:\n                    continue\n        else:\n            for z_cls in self.arod_dharbs_map:\n                try:\n                    last_feet.add(str(z_cls(self.last_tafeela).modified_tafeela))\n                except AssertionError:\n                    continue\n    else:\n        if shatr_index == 0:  # Sadr -&gt; Arudh\n            for z_cls in self.arod_dharbs_map.keys():\n                try:\n                    last_feet.add(str(z_cls(self.last_tafeela).modified_tafeela))\n                except AssertionError:\n                    continue\n        else:  # Ajuz -&gt; Dharb\n            for d_list in self.arod_dharbs_map.values():\n                for z_cls in d_list:\n                    try:\n                        last_feet.add(str(z_cls(self.last_tafeela).modified_tafeela))\n                    except AssertionError:\n                        continue\n\n    allowed_per_index.append(list(last_feet))\n    return allowed_per_index\n</code></pre>"},{"location":"api/#arudi-converter","title":"Arudi Converter","text":""},{"location":"api/#pyarud.arudi.ArudiConverter","title":"<code>pyarud.arudi.ArudiConverter</code>","text":"Source code in <code>pyarud/arudi.py</code> <pre><code>class ArudiConverter:\n    def __init__(self):\n        self.harakat = [KASRA, FATHA, DAMMA]  # kasra, fatha, damma\n        self.sukun = [SUKUN]  # sukun\n        self.mostly_saken = [ALEF, WAW, ALEF_MAKSURA, YEH]  # alef, waw, alef maqsurah, ya'a\n        self.tnween_chars = [DAMMATAN, KASRATAN, FATHATAN]  # damm, kasra, fatha tanween\n        self.shadda_chars = [SHADDA]\n        self.all_chars = list(LETTERS + \" \")\n        self.prem_chars = (\n            self.harakat + self.sukun + self.mostly_saken + self.tnween_chars + self.shadda_chars + self.all_chars\n        )\n\n        # Word replacements for Arudi writing\n        self.CHANGE_LST = {\n            \"\u0647\u0630\u0627\": \"\u0647\u064e\u0627\u0630\u064e\u0627\",\n            \"\u0647\u0630\u0647\": \"\u0647\u064e\u0627\u0630\u0650\u0647\",\n            \"\u0647\u0630\u0627\u0646\": \"\u0647\u064e\u0627\u0630\u064e\u0627\u0646\",\n            \"\u0647\u0630\u064a\u0646\": \"\u0647\u064e\u0627\u0630\u064e\u064a\u0646\",\n            \"\u0647\u0624\u0644\u0627\u0621\": \"\u0647\u064e\u0627\u0624\u064f\u0644\u064e\u0627\u0621\",\n            \"\u0630\u0644\u0643\": \"\u0630\u064e\u0627\u0644\u0650\u0643\",\n            \"\u0630\u0644\u0643\u0645\u0627\": \"\u0630\u064e\u0627\u0644\u0650\u0643\u064f\u0645\u064e\u0627\",\n            \"\u0630\u0644\u0643\u0645\": \"\u0630\u064e\u0627\u0644\u0650\u0643\u064f\u0645\",\n            \"\u0623\u0648\u0644\u0626\u0643\": \"\u0623\u064f\u0644\u064e\u0627\u0626\u0650\u0643\",\n            \"\u0623\u0648\u0644\u0626\u0643\u0645\": \"\u0623\u064f\u0644\u064e\u0627\u0626\u0650\u0643\u064f\u0645\",\n            \"\u0627\u0644\u0644\u0647\": \"\u0627\u0644\u0644\u0651\u064e\u0627\u0647\",\n            \"\u0627\u0644\u0644\u0647\u0645\": \"\u0627\u0644\u0644\u0651\u064e\u0627\u0647\u064f\u0645\u0651\",\n            \"\u0625\u0644\u0647\": \"\u0625\u0650\u0644\u064e\u0627\u0647\",\n            \"\u0627\u0644\u0625\u0644\u0647\": \"\u0627\u0644\u0625\u0650\u0644\u064e\u0627\u0647\",\n            \"\u0625\u0644\u0647\u064a\": \"\u0625\u0650\u0644\u064e\u0627\u0647\u064a\",\n            \"\u0625\u0644\u0647\u0646\u0627\": \"\u0625\u0650\u0644\u064e\u0627\u0647\u0646\u0627\",\n            \"\u0625\u0644\u0647\u0643\u0645\": \"\u0625\u0650\u0644\u064e\u0627\u0647\u0643\u0645\",\n            \"\u0625\u0644\u0647\u0647\u0645\": \"\u0625\u0650\u0644\u064e\u0627\u0647\u0647\u0645\",\n            \"\u0625\u0644\u0647\u0647\u0646\": \"\u0625\u0650\u0644\u064e\u0627\u0647\u0647\u0646\",\n            \"\u0631\u062d\u0645\u0646\": \"\u0631\u064e\u062d\u0645\u064e\u0627\u0646\",\n            \"\u0627\u0644\u0631\u062d\u0645\u0646\": \"\u0627\u0644\u0631\u0651\u064e\u062d\u0645\u064e\u0627\u0646\",\n            \"\u0637\u0627\u0648\u0633\": \"\u0637\u064e\u0627\u0648\u064f\u0648\u0633\",\n            \"\u062f\u0627\u0648\u062f\": \"\u062f\u064e\u0627\u0648\u064f\u0648\u062f\",\n            \"\u0644\u0643\u0646\": \"\u0644\u064e\u0627\u0643\u0650\u0646\",\n            \"\u0644\u0643\u0646\u0651\": \"\u0644\u064e\u0627\u0643\u0650\u0646\u0651\",\n            \"\u0644\u0643\u0646\u0647\": \"\u0644\u064e\u0627\u0643\u0650\u0646\u0651\u0647\u064f\",\n            \"\u0637\u0647\": \"\u0637\u064e\u0627\u0647\u064e\" + FATHA,\n            \"\u0644\u0644\u0647\": \"\u0644\u0650\u0644\u0644\u064e\u0627\u0647\u0650\",\n            \"\u0622\u0647\": \"\u0623\u064e\u0627\u0647\u0650\",\n            \"\u0647\u0648\": \"\u0647\u0652\u0648\u064e\",\n            \"\u0647\u064a\": \"\u0647\u0652\u064a\u064e\",\n        }\n\n    def register_custom_spelling(self, word, replacement):\n        \"\"\"\n        Register a custom Arudi spelling for a specific word.\n\n        Args:\n            word (str): The word (without diacritics) to replace (e.g., '\u0644\u0643\u0646').\n            replacement (str): The phonetic Arudi spelling (e.g., '\u0644\u064e\u0627\u0643\u0650\u0646').\n        \"\"\"\n        self.CHANGE_LST[word] = replacement\n\n    def _normalize_shadda(self, text):\n        # Ensure Shadda comes before Harakat/Tanween\n        harakat_all = \"\".join(self.harakat + self.tnween_chars)\n        shadda = \"\".join(self.shadda_chars)\n        return re.sub(f\"([{harakat_all}])([{shadda}])\", r\"\\2\\1\", text)\n\n    def _normalize_orthography(self, text):\n        # Normalize Dagger Alif (Superscript Alif) to standard Alif\n        text = text.replace(\"\\u0670\", ALEF)\n\n        # Remove Harakat from standard Alif (ALEF cannot carry vowel unless it's Hamza)\n        # This fixes cases where text has L+A+Fatha (treated as L+A(mover))\n        harakat_pattern = f\"[{FATHA}{DAMMA}{KASRA}]\"\n        text = re.sub(f\"{ALEF}{harakat_pattern}\", ALEF, text)\n\n        # Normalize Alif + Tanween Fath -&gt; Tanween Fath + Alif\n        # (Ensures consistent processing order)\n        text = re.sub(f\"{ALEF}{FATHATAN}\", f\"{FATHATAN}{ALEF}\", text)\n\n        return text\n\n    def _normalize_ligatures(self, text):\n        # Decompose Lam-Alif ligatures with potential diacritics\n        # Matches Ligature + Optional Haraka\n        # Replaces with Lam + Optional Haraka + Second Letter\n\n        harakat_pattern = f\"[{''.join(self.harakat + self.tnween_chars)}]\"\n\n        def replace_la(match):\n            # match.group(0) is the ligature + optional haraka\n            # We want L + haraka (if any) + A\n            s = match.group(0)\n            haraka = s[1:] if len(s) &gt; 1 else \"\"\n            return \"\u0644\" + haraka + \"\u0627\"\n\n        def replace_la_hamza_above(match):\n            s = match.group(0)\n            haraka = s[1:] if len(s) &gt; 1 else \"\"\n            return \"\u0644\" + haraka + \"\u0623\"\n\n        def replace_la_hamza_below(match):\n            s = match.group(0)\n            haraka = s[1:] if len(s) &gt; 1 else \"\"\n            return \"\u0644\" + haraka + \"\u0625\"\n\n        def replace_la_madda(match):\n            s = match.group(0)\n            haraka = s[1:] if len(s) &gt; 1 else \"\"\n            return \"\u0644\" + haraka + \"\u0622\"\n\n        text = re.sub(f\"\ufefb({harakat_pattern})?\", replace_la, text)\n        text = re.sub(f\"\ufef7({harakat_pattern})?\", replace_la_hamza_above, text)\n        text = re.sub(f\"\ufef9({harakat_pattern})?\", replace_la_hamza_below, text)\n        text = re.sub(f\"\ufef5({harakat_pattern})?\", replace_la_madda, text)\n\n        return text\n\n    def _resolve_wasl(self, text):\n        \"\"\"\n        Handles Hamzat al-Wasl (Connecting Alif) and Iltiqa al-Sakinayn.\n        1. Drop Long Vowel + Space + Alif Wasl (e.g. \"Idh\u0101 Ishtadda\" -&gt; \"Idhshtadda\").\n        2. Drop Space + Alif Wasl (e.g. \"Bika Al-\" -&gt; \"Bikal-\").\n        \"\"\"\n        # Pattern: Letter + (Optional Diacritic) + (Long Vowel) + Space + Alif -&gt; Letter + Diacritic\n        # The original regex was flawed because it did not capture the diacritic.\n        # This version captures the letter and its optional diacritic, preserving it.\n        # Using S* to handle multiple diacritics (e.g., shadda + fatha).\n        text = re.sub(r\"([^\\s]\\S*)([\u0627\u0649\u064a\u0648])\\s+\u0627\", r\"\\1\", text)\n\n        # Pattern: Space + Alif (Wasl) -&gt; Drop both\n        # Matches any word starting with bare Alif preceded by space.\n        text = re.sub(r\"\\s+\u0627\", \"\", text)\n\n        # 3. Drop Alif of \"Allah\" if prefixed by Fa/Wa/Ba/Ta/Kaf\n        # Pattern: (Prefix)(Vowel?)Alif(LamLam) -&gt; (Prefix)(Vowel?)LamLam\n        prefixes = \"\\u0641\\u0648\\u0628\\u062a\\u0643\"\n        harakat = \"\".join(self.harakat)\n        text = re.sub(f\"([{prefixes}])([{harakat}]?)\u0627(\u0644\u0644)\", r\"\\1\\2\\3\", text)\n\n        return text\n\n    def _handle_space(self, plain_chars):\n        if not plain_chars:\n            return plain_chars\n\n        if plain_chars[-1] == \" \":\n            return plain_chars[:-2]\n        else:\n            return plain_chars[:-1]\n\n    def _remove_extra_harakat(self, text):\n        out = \"\"\n        i = 0\n        while i &lt; len(text):\n            if i &lt; len(text) - 1:\n                if text[i] in self.harakat and text[i + 1] in self.harakat:\n                    i += 1\n                    continue\n            out += text[i]\n            i += 1\n        return out\n\n    def _process_specials_before(self, bait):\n        # Handle specific starting Alif cases\n        if bait and bait[0] == \"\u0627\":\n            # Heuristic: randomly choose or based on context. Bohour used random.\n            # We'll default to Fatha for consistency in deterministic output,\n            # or Hamza with Fatha.\n            bait = \"\u0623\u064e\" + bait[1:]\n\n        # Detach prefixes to handle Al- logic (WaAl -&gt; Wa Al)\n        # Matches: Fa, Waw, Ba, Ta, Kaf followed by Al, at start of word\n        bait = re.sub(r\"(^|\\s)([\u0641\u0648\u0628\u062a\u0643])([\u064e\u0650\u064f])?\u0627\u0644\", r\"\\1\\2\\3 \u0627\u0644\", bait)\n\n        # Solar Lam Handling: Al + Sun Letter -&gt; A + Sun Letter\n        # Drops the Lam which is silent in Solar cases\n        sun_letters = \"\u062a\u062b\u062f\u0630\u0631\u0632\u0633\u0634\u0635\u0636\u0637\u0638\u0644\u0646\"\n        bait = re.sub(f\" \u0627\u0644([{sun_letters}])\", r\" \u0627\\1\", bait)\n\n        bait = bait.replace(\"\u0648\u0627 \", \"\u0648 \")\n        if bait.endswith(\"\u0648\u0627\"):\n            bait = bait[:-1]\n\n        bait = bait.replace(\"\u0648\u0652\u0627\", \"\u0648\")\n        if bait.endswith(\"\u0648\u0652\u0627\"):\n            bait = bait[:-2] + \"\u0648\"\n\n        # Common substitutions\n        bait = bait.replace(\"\u0627\u0644\u0644\u0647\", \"\u0627\u0644\u0644\u0627\u0647\")\n        bait = bait.replace(\"\u0627\u0644\u0644\u0651\u0647\", \"\u0627\u0644\u0644\u0647\")\n        bait = bait.replace(\"\u0625\u0644\u0651\u064e\u0627\", \"\u0625\u0650\u0644\u0651\u0627\")\n        bait = bait.replace(\"\u0646\u0652 \u0627\u0644\", \"\u0646\u064e \u0627\u0644\")\n        bait = bait.replace(\"\u0644\u0652 \u0627\u0644\", \"\u0644\u0650 \u0627\u0644\")\n        bait = bait.replace(\"\u0625\u0644\u064e\u0649\", \"\u0625\u0650\u0644\u064e\u0649\")\n        bait = bait.replace(\"\u0625\u0630\u064e\u0627\", \"\u0625\u0650\u0630\u064e\u0627\")\n        bait = bait.replace(\"\u0643 \", \"\u0643\u064e \")\n        bait = bait.replace(\" \u0627\u0644 \", \" \u0627\u0644\u0652 \")\n        bait = bait.replace(\"\u0652 \u0627\u0644\", \"\u0650 \u0627\u0644\")\n        bait = bait.replace(\"\u0639\u064e\u0645\u0652\u0631\u064d\u0648\", \"\u0639\u064e\u0645\u0652\u0631\u064d\")\n        bait = bait.replace(\"\u0639\u064e\u0645\u0652\u0631\u064f\u0648\", \"\u0639\u064e\u0645\u0652\u0631\u064f\")\n\n        # Word replacements from CHANGE_LST\n        out = []\n        valid_prefixes = [\"\u0648\", \"\u0641\", \"\u0643\", \"\u0628\", \"\u0644\", \"\u0648\u0628\", \"\u0641\u0643\", \"\u0648\u0644\", \"\u0641\u0644\"]\n\n        # Prepare regex for stripping harakat but keeping shadda\n        # Exclude SHADDA from removal list\n        removable_chars = self.harakat + self.sukun + self.tnween_chars\n        strip_harakat_pattern = f\"[{''.join(removable_chars)}]\"\n\n        for word in bait.split(\" \"):\n            # 1. Try match with Shadda preserved (e.g. for '\u0644\u0643\u0646\u0651')\n            cleaned_with_shadda = re.sub(strip_harakat_pattern, \"\", word)\n            # 2. Try match with Shadda removed (standard)\n            cleaned_plain = strip_tashkeel(word)\n\n            found = False\n\n            # Check Exact Match (Shadda first, then Plain)\n            for candidate in [cleaned_with_shadda, cleaned_plain]:\n                if candidate in self.CHANGE_LST:\n                    out.append(self.CHANGE_LST[candidate])\n                    found = True\n                    break\n            if found: \n                continue\n\n            # Prefix check\n            # We iterate candidates again to check prefixes\n            for candidate in [cleaned_with_shadda, cleaned_plain]:\n                if found:\n                    break\n                for key, replacement in self.CHANGE_LST.items():\n                    if candidate.endswith(key):\n                        prefix = candidate[:-len(key)]\n                        if prefix in valid_prefixes:\n                            prefix_harakat = {\n                                \"\u0648\": \"\u0648\u064e\", \"\u0641\": \"\u0641\u064e\", \"\u0643\": \"\u0643\u064e\", \"\u0628\": \"\u0628\u0650\", \"\u0644\": \"\u0644\u0650\"\n                            }\n\n                            # Construct new word\n                            new_prefix = \"\"\n                            for p_char in prefix:\n                                new_prefix += prefix_harakat.get(p_char, p_char) \n\n                            out.append(new_prefix + replacement)\n                            found = True\n                            break\n\n            if not found:\n                out.append(word)\n\n        bait = \" \".join(out)\n\n        # Ensure second char isn't a bare letter if first is\n        if len(bait) &gt; 1 and bait[1] in self.all_chars:\n            bait = bait[0] + self.harakat[1] + bait[1:]\n\n        # Filter trailing alif after tanween\n        final_chars = []\n        i = 0\n        while i &lt; len(bait):\n            if bait[i] == \"\u0627\" and i &gt; 0 and bait[i - 1] in self.tnween_chars:\n                i += 1\n                # skip following harakat if any\n                if i &lt; len(bait) and bait[i] in self.harakat + self.sukun + self.tnween_chars + self.shadda_chars:\n                    i += 1\n                continue\n            final_chars.append(bait[i])\n            i += 1\n\n        return \"\".join(final_chars)\n\n    def _process_specials_after(self, bait):\n        bait = bait.replace(\"\u0629\u0646\", \"\u062a\u0646\")\n        return bait\n\n    def _extract_pattern(self, text, saturate=True, muqayyad=False):\n        \"\"\"\n        Core logic to extract binary pattern and arudi text.\n        Based on Bohour's extract_tf3eelav3.\n        \"\"\"\n        text = self._remove_extra_harakat(text)\n        chars = list(text.replace(ALEF_MADDA, \"\u0621\u064e\u0627\").strip())  # Replace Madda\n        chars = [c for c in chars if c in self.prem_chars]\n        chars = list(re.sub(\" +\", \" \", \"\".join(chars).strip()))\n\n        # DEBUG\n        # print(f\"Trace: {chars}\")\n\n        out_pattern = \"\"\n        plain_chars = \"\"\n\n        i = 0\n        while i &lt; len(chars) - 1:\n            char = chars[i]\n            next_char = chars[i + 1]\n            # print(f\"i={i}, char={char}, next={next_char}\")\n\n            if char in self.all_chars:\n                if char == \" \":\n                    plain_chars += char\n                    i += 1\n                    continue\n\n                # Lookahead\n                if next_char == \" \" and i + 2 &lt; len(chars):\n                    next_char = chars[i + 2]\n\n                next_next_char = None\n                if i &lt; len(chars) - 2:\n                    next_next_char = chars[i + 2]\n\n                prev_digit = out_pattern[-1] if len(out_pattern) &gt; 0 else \"\"\n\n                # Logic\n                if next_char in self.harakat:\n                    # Check for Muqayyad (Restricted Rhyme) at the very end\n                    # If we are at the last character group (char + haraka is end of string)\n                    is_last_group = (i + 2 &gt;= len(chars))\n                    # Or if followed by space then end? (Arudi usually strips trailing spaces but let's be safe)\n\n                    if muqayyad and is_last_group:\n                        # Treat as Sakin (drop vowel)\n                        if prev_digit != \"0\":\n                            out_pattern += \"0\"\n                            plain_chars += char\n                        else:\n                            # If prev was Sakin, we have Iltiqa Sakinayn at end.\n                            # In Muqayyad rhyme, this is allowed (e.g. 'Mard').\n                            # But typically we avoid 00. \n                            # Standard Arudi: 00 is allowed at end (Waqf).\n                            out_pattern += \"0\"\n                            plain_chars += char\n                        # Skip the haraka\n                    else:\n                        out_pattern += \"1\"\n                        plain_chars += char\n\n                elif next_char in self.sukun:\n                    if prev_digit != \"0\":\n                        out_pattern += \"0\"\n                        plain_chars += char\n                    elif (i + 1) == len(chars) - 1:\n                        # End of line sukun handling: Allow consecutive Sukun (00)\n                        out_pattern += \"0\"\n                        plain_chars += char\n                    else:\n                        plain_chars = self._handle_space(plain_chars) + char\n\n                elif next_char in self.tnween_chars:\n                    if char != \"\u0627\":\n                        plain_chars += char\n                    plain_chars += \"\u0646\"\n                    out_pattern += \"10\"\n\n                    # Skip trailing Alif (Tanween Fath)\n                    if i + 2 &lt; len(chars) and chars[i + 2] == \"\u0627\":\n                        i += 1\n\n                elif next_char in self.shadda_chars:\n                    if prev_digit != \"0\":\n                        plain_chars += char + char\n                        out_pattern += \"01\"\n                    else:\n                        plain_chars = self._handle_space(plain_chars) + char + char\n                        out_pattern += \"1\"\n\n                    # Check what follows Shadda\n                    if i + 2 &lt; len(chars):\n                        if chars[i + 2] in self.harakat:\n                            # Check Muqayyad for Shadda+Harakah at end?\n                            # Example: \"Radd\" (R + Shadda).\n                            # If \"Raddu\" -&gt; R(0) R(1).\n                            # If Muqayyad \"Radd\" -&gt; R(0) R(0).\n                            is_last_shadda_group = (i + 3 &gt;= len(chars))\n                            if muqayyad and is_last_shadda_group:\n                                # We already added '01' or '1'. The '1' corresponds to the second letter being Mover.\n                                # If Muqayyad, the second letter should be Sakin.\n                                # So '01' -&gt; '00'. '1' -&gt; '0'.\n                                # We need to fix the last digit added.\n                                out_pattern = out_pattern[:-1] + \"0\"\n                                # Skip the harakah\n                                i += 1\n                            else:\n                                i += 1  # Skip harakat processing next loop\n                        elif chars[i + 2] in self.tnween_chars:\n                            i += 1\n                            plain_chars += \"\u0646\"\n                            out_pattern += \"0\"\n\n                            # Skip trailing Alif (Shadda + Tanween Fath)\n                            if i + 2 &lt; len(chars) and chars[i + 2] == \"\u0627\":\n                                i += 1\n\n                elif next_char in [ALEF, ALEF_MAKSURA]:\n                    out_pattern += \"10\"\n                    plain_chars += char + next_char\n\n                elif next_char in self.all_chars:\n                    # Letter followed by Letter (implies first is Sakin if no haraka in betweeen?)\n                    # Or assumes implicit sukun?\n                    if prev_digit != \"0\":\n                        out_pattern += \"0\"\n                        plain_chars += char\n                    elif prev_digit == \"0\" and i + 1 &lt; len(chars) and chars[i + 1] == \" \":\n                        # Special case from Bohour\n                        out_pattern += \"1\"\n                        plain_chars += char\n                    else:\n                        plain_chars = self._handle_space(plain_chars) + char\n                        out_pattern += \"0\"\n                    i -= 1  # Backtrack? This logic in Bohour is tricky.\n                    # If we assumed it was a letter but it's followed by a letter, we treat current as sakin.\n                    # The i -= 1 might be to re-process? No, i += 2 at end.\n\n                # Ha' al-Gha'ib (He) handling\n                # Only saturate if previous letter was Mutaharrik (prev_digit != \"0\")\n                # And NOT muqayyad (if muqayyad, we don't saturate)\n                if not muqayyad and next_next_char == \" \" and prev_digit != \"0\":\n                    if char == \"\u0647\":\n                        if next_char == self.harakat[0]:  # Kasra\n                            plain_chars += \"\u064a\"\n                            out_pattern += \"0\"\n                        if next_char == self.harakat[2]:  # Damma\n                            plain_chars += \"\u0648\"\n                            out_pattern += \"0\"\n\n                i += 2  # Advance past char and its diacritic/follower\n            elif char == \"\u0627\":\n                # Alef encountered as 'char' (e.g. after a diacritic consumed the previous letter)\n                out_pattern += \"0\"\n                plain_chars += char\n                i += 1\n            else:\n                i += 1\n\n        # Finalize\n        # If Muqayyad, we don't saturate.\n        # If Not Muqayyad, we saturate.\n\n        if not muqayyad and saturate and out_pattern and out_pattern[-1] != \"0\":\n            out_pattern += \"0\"  # Always end with sukun (Qafiyah)\n\n        # Ashba' (Saturation) of last letter\n        # Only if not muqayyad\n        if not muqayyad and saturate and chars:\n            last_char = chars[-1]\n            if last_char == self.harakat[0]:  # Kasra\n                plain_chars += \"\u064a\"\n            elif last_char == self.tnween_chars[1]:  # Kasr Tanween\n                plain_chars = plain_chars[:-1] + \"\u064a\"\n            elif last_char == self.harakat[1]:  # Fatha\n                plain_chars += \"\u0627\"\n            elif last_char == self.harakat[2]:  # Damma\n                plain_chars += \"\u0648\"\n            elif last_char == self.tnween_chars[0]:  # Damm Tanween\n                plain_chars = plain_chars[:-1] + \"\u0648\"\n            elif last_char in self.mostly_saken and len(chars) &gt; 1 and chars[-2] not in self.tnween_chars:\n                plain_chars += last_char\n\n        return plain_chars, out_pattern\n\n    def prepare_text(self, text, saturate=True, muqayyad=False):\n        \"\"\"\n        Converts standard Arabic text into Arudi style and extracts the binary pattern.\n        \"\"\"\n        text = text.strip()\n        if not text:\n            return \"\", \"\"\n\n        # print(f\"Original: {text}\")\n        text = self._normalize_orthography(text)\n        # print(f\"Norm Ortho: {text}\")\n        text = self._normalize_ligatures(text)\n        text = self._normalize_shadda(text)\n        preprocessed = self._process_specials_before(text)\n        # print(f\"Specials Before: {preprocessed}\")\n        preprocessed = self._resolve_wasl(preprocessed)\n        # print(f\"Resolve Wasl: {preprocessed}\")\n        arudi_style, pattern = self._extract_pattern(preprocessed, saturate=saturate, muqayyad=muqayyad)\n        arudi_style = self._process_specials_after(arudi_style)\n\n        return arudi_style, pattern\n</code></pre>"},{"location":"api/#pyarud.arudi.ArudiConverter.prepare_text","title":"<code>prepare_text(text, saturate=True, muqayyad=False)</code>","text":"<p>Converts standard Arabic text into Arudi style and extracts the binary pattern.</p> Source code in <code>pyarud/arudi.py</code> <pre><code>def prepare_text(self, text, saturate=True, muqayyad=False):\n    \"\"\"\n    Converts standard Arabic text into Arudi style and extracts the binary pattern.\n    \"\"\"\n    text = text.strip()\n    if not text:\n        return \"\", \"\"\n\n    # print(f\"Original: {text}\")\n    text = self._normalize_orthography(text)\n    # print(f\"Norm Ortho: {text}\")\n    text = self._normalize_ligatures(text)\n    text = self._normalize_shadda(text)\n    preprocessed = self._process_specials_before(text)\n    # print(f\"Specials Before: {preprocessed}\")\n    preprocessed = self._resolve_wasl(preprocessed)\n    # print(f\"Resolve Wasl: {preprocessed}\")\n    arudi_style, pattern = self._extract_pattern(preprocessed, saturate=saturate, muqayyad=muqayyad)\n    arudi_style = self._process_specials_after(arudi_style)\n\n    return arudi_style, pattern\n</code></pre>"},{"location":"architecture/","title":"Technical Architecture","text":"<p>PyArud is designed as a modular pipeline. It separates the linguistic processing (normalization, phonetics) from the mathematical analysis (pattern matching).</p>"},{"location":"architecture/#1-the-pipeline","title":"1. The Pipeline","text":"<p>Data flows through the system in three stages:</p> <ol> <li>Input: Raw Arabic text (Unicode strings).</li> <li>Conversion (<code>ArudiConverter</code>): Transforms text into Arudi Phonetic representation and then into a binary string.</li> <li>Analysis (<code>ArudhProcessor</code>): Matches binary strings against precomputed meter patterns and performs detailed foot-by-foot analysis.</li> </ol>"},{"location":"architecture/#2-arudi-conversion-arudipy","title":"2. Arudi Conversion (<code>arudi.py</code>)","text":"<p>The <code>ArudiConverter</code> class is the linguistic engine. It does not know about meters; it only knows about phonetics.</p>"},{"location":"architecture/#key-components","title":"Key Components","text":"<ul> <li>Constants: Uses <code>pyarabic.araby</code> constants (<code>FATHA</code>, <code>SUKUN</code>, etc.) for robustness.</li> <li><code>CHANGE_LST</code>: A dictionary of words with implicit letters (e.g., <code>\u0647\u0630\u0627</code> $\\rightarrow$ <code>\u0647\u0627\u0630\u0627</code>).<ul> <li>Extensibility: Users can add to this via <code>register_custom_spelling()</code>.</li> </ul> </li> <li>Regex Engine: Uses regular expressions to handle context-dependent rules:<ul> <li>Iltiqa Sakinayn: Dropping vowels before <code>Al-</code>.</li> <li>Solar Lam: Assimilating <code>Al-</code> into solar letters.</li> </ul> </li> <li>Tokenization: The text is processed letter-by-letter (or token-by-token) to generate the binary string (<code>1</code> for Mutaharrik, <code>0</code> for Sakin).</li> </ul>"},{"location":"architecture/#3-the-meter-system-bahrpy-tafeelapy","title":"3. The Meter System (<code>bahr.py</code> &amp; <code>tafeela.py</code>)","text":"<p>PyArud uses a strict Object-Oriented model to define meters.</p>"},{"location":"architecture/#tafeela-class","title":"<code>Tafeela</code> Class","text":"<p>Represents a single foot (e.g., <code>Mustafelon</code>). -   Stores the standard binary pattern (<code>1010110</code>). -   Defines <code>allowed_zehafs</code>: A list of Modification classes (e.g., <code>Khaban</code>) that can modify this specific foot. -   Generative: The <code>all_zehaf_tafeela_forms()</code> method dynamically generates all valid permutations of the foot based on its allowed modifications.</p>"},{"location":"architecture/#bahr-class","title":"<code>Bahr</code> Class","text":"<p>Represents a poetic meter (e.g., <code>Kamel</code>). -   Composition: Defined as a tuple of <code>Tafeela</code> classes (e.g., <code>(Mutafaelon, Mutafaelon, Mutafaelon)</code>). -   Arudh/Dharb Map: A dictionary defining valid endings.     -   Example: <code>{NoZehafNorEllah: (NoZehafNorEllah, Hadhf)}</code>. This means \"If the Arudh is healthy, the Dharb can be healthy or deleted.\" -   Pattern Generation: The <code>detailed_patterns</code> property permutes all valid <code>Hashw</code> (interior) feet with all valid <code>Arudh/Dharb</code> endings to create a comprehensive set of valid line patterns.</p>"},{"location":"architecture/#4-the-processing-engine-processorpy","title":"4. The Processing Engine (<code>processor.py</code>)","text":"<p>The <code>ArudhProcessor</code> binds everything together.</p>"},{"location":"architecture/#algorithm-cubic-similarity-scoring","title":"Algorithm: Cubic Similarity Scoring","text":"<p>To distinguish between meters with similar patterns (e.g., a <code>Rajaz</code> line that looks like <code>Kamel</code> due to Zihaf), the processor uses a cubic scoring function: $$ Score = (RawRatio)^6 $$ This penalizes small mismatches heavily, ensuring that only structurally sound matches rise to the top.</p>"},{"location":"architecture/#algorithm-greedy-foot-analysis","title":"Algorithm: Greedy Foot Analysis","text":"<p>Once a meter is detected, the processor performs a \"Greedy Match\" to segment the verse. 1.  It looks at the binary stream. 2.  It compares the beginning of the stream against all valid forms of the first foot. 3.  It selects the longest valid match (to prefer <code>Mustaf'ilun</code> over <code>Mutaf'ilun</code> if both fit, though context matters). 4.  It consumes that segment and moves to the next foot.</p> <p>This approach allows PyArud to pinpoint exactly where a verse breaks, rather than just failing the whole line.</p>"},{"location":"concepts/","title":"Core Concepts","text":"<p>Understanding how PyArud (\u0628\u064a\u0639\u0631\u0648\u0636) analyzes poetry requires familiarity with a few key concepts from Arabic prosody (Arud).</p>"},{"location":"concepts/#1-the-arudi-pattern","title":"1. The Arudi Pattern","text":"<p>At its core, Arud is binary. Every letter in a spoken poem is either: - Mutaharrik (Moved): Has a vowel (Fatha, Damma, Kasra). Represented as <code>1</code>. - Sakin (Still): Has a Sukun or is a long vowel (Alif, Waw, Ya). Represented as <code>0</code>.</p> <p>PyArud converts your text into this binary string. Example: <code>\u0641\u064e\u0639\u064f\u0648\u0644\u064f\u0646\u0652</code> (Fa-u-lun) -&gt; <code>11010</code></p>"},{"location":"concepts/#2-meters-buhur","title":"2. Meters (Buhur)","text":"<p>Arabic poetry is classified into 16 standard meters (Buhur), each defined by a specific rhythm of feet (Tafila).</p> <p>Below is the list of meters supported by PyArud, along with their standard mnemonic (Meftah) and feet.</p> Meter (Bahr) Mnemonic (Meftah) Standard Feet Tawil \u0637\u064e\u0648\u0650\u064a\u0644\u064c \u0644\u064e\u0647\u064f \u062f\u064f\u0648\u0646\u064e \u0627\u0644\u0652\u0628\u064f\u062d\u064f\u0648\u0631\u0650 \u0641\u064e\u0636\u064e\u0627\u0626\u0650\u0644\u064f <code>Fa'ulun Mafa'ilun Fa'ulun Mafa'ilun</code> Madid \u0644\u0650\u0645\u064e\u062f\u0650\u064a\u062f\u0650 \u0627\u0644\u0634\u0651\u0650\u0639\u0652\u0631\u0650 \u0639\u0650\u0646\u0652\u062f\u0650\u064a \u0635\u0650\u0641\u064e\u0627\u062a\u064f <code>Fa'ilatun Fa'ilun Fa'ilatun</code> Basit \u0625\u0650\u0646\u0651\u064e \u0627\u0644\u0652\u0628\u064e\u0633\u0650\u064a\u0637\u064e \u0644\u064e\u062f\u064e\u064a\u0652\u0647\u0650 \u064a\u064f\u0628\u0652\u0633\u064e\u0637\u064f \u0627\u0644\u0652\u0623\u064e\u0645\u064e\u0644\u064f <code>Mustaf'ilun Fa'ilun Mustaf'ilun Fa'ilun</code> Wafir \u0628\u064f\u062d\u064f\u0648\u0631\u064f \u0627\u0644\u0634\u0651\u0650\u0639\u0652\u0631\u0650 \u0648\u064e\u0627\u0641\u0650\u0631\u064f\u0647\u064e\u0627 \u062c\u064e\u0645\u0650\u064a\u0644\u064f <code>Mufa'alatun Mufa'alatun Fa'ulun</code> Kamil \u0643\u064e\u0645\u064f\u0644\u064e \u0627\u0644\u0652\u062c\u064e\u0645\u064e\u0627\u0644\u064f \u0645\u0650\u0646\u064e \u0627\u0644\u0652\u0628\u064f\u062d\u064f\u0648\u0631\u0650 \u0627\u0644\u0652\u0643\u064e\u0627\u0645\u0650\u0644\u064f <code>Mutafa'ilun Mutafa'ilun Mutafa'ilun</code> Hazaj \u0639\u064e\u0644\u064e\u0649 \u0627\u0644\u0652\u0623\u064e\u0647\u0652\u0632\u064e\u0627\u062c\u0650 \u062a\u064e\u0633\u0652\u0647\u0650\u064a\u0644\u064f <code>Mafa'ilun Mafa'ilun</code> Rajaz \u0641\u0650\u064a \u0623\u064e\u0628\u0652\u062d\u064f\u0631\u0650 \u0627\u0644\u0652\u0623\u064e\u0631\u0652\u062c\u064e\u0627\u0632\u0650 \u0628\u064e\u062d\u0652\u0631\u064c \u064a\u064e\u0633\u0652\u0647\u064f\u0644\u064f <code>Mustaf'ilun Mustaf'ilun Mustaf'ilun</code> Ramal \u0631\u064e\u0645\u064e\u0644\u064f \u0627\u0644\u0652\u0623\u064e\u0628\u0652\u062d\u064f\u0631\u0650 \u064a\u064e\u0631\u0652\u0648\u0650\u064a\u0647\u0650 \u0627\u0644\u062b\u0651\u0650\u0642\u064e\u0627\u062a\u064f <code>Fa'ilatun Fa'ilatun Fa'ilatun</code> Saree \u0628\u064e\u062d\u0652\u0631\u064c \u0633\u064e\u0631\u0650\u064a\u0639\u064c \u0645\u064e\u0627 \u0644\u064e\u0647\u064f \u0633\u064e\u0627\u062d\u0650\u0644\u064f <code>Mustaf'ilun Mustaf'ilun Fa'ilun</code> Munsarih \u0645\u064f\u0646\u0652\u0633\u064e\u0631\u0650\u062d\u064c \u0641\u0650\u064a\u0647\u0650 \u064a\u064f\u0636\u0652\u0631\u064e\u0628\u064f \u0627\u0644\u0652\u0645\u064e\u062b\u064e\u0644\u064f <code>Mustaf'ilun Maf'ulatu Mufta'ilun</code> Khafif \u064a\u064e\u0627 \u062e\u064e\u0641\u0650\u064a\u0641\u0627\u064b \u062e\u064e\u0641\u0651\u064e\u062a\u0652 \u0628\u0650\u0647\u0650 \u0627\u0644\u0652\u062d\u064e\u0631\u064e\u0643\u064e\u0627\u062a\u064f <code>Fa'ilatun Mustaf'ilun Fa'ilatun</code> Mudhari \u062a\u064e\u0639\u064e\u062f\u0651\u064e \u0645\u064e\u0639\u064e \u0627\u0644\u0652\u0639\u064e\u0648\u064e\u0627\u0642\u0650\u0644\u0652 <code>Mafa'ilun Fa'ilatun</code> Muqtadhib \u0627\u0642\u0652\u062a\u064e\u0636\u0650\u0628\u0652 \u0643\u064e\u0645\u064e\u0627 \u0633\u064e\u0623\u064e\u0644\u064f\u0648\u0627 <code>Maf'ulatu Mufta'ilun</code> Mujtath \u0625\u0650\u0646\u0652 \u062c\u064f\u062b\u0651\u064e\u062a\u0650 \u0627\u0644\u0652\u062d\u064e\u0631\u064e\u0643\u064e\u0627\u062a\u064f <code>Mustaf'ilun Fa'ilatun</code> Mutakarib \u0639\u064e\u0646\u0650 \u0627\u0644\u0652\u0645\u064f\u062a\u064e\u0642\u064e\u0627\u0631\u0650\u0628\u0650 \u0642\u064e\u0627\u0644\u064e \u0627\u0644\u0652\u062e\u064e\u0644\u0650\u064a\u0644\u064f <code>Fa'ulun Fa'ulun Fa'ulun Fa'ulun</code> Mutadarak \u062d\u064e\u0631\u064e\u0643\u064e\u0627\u062a\u064f \u0627\u0644\u0652\u0645\u064f\u062d\u0652\u062f\u064e\u062b\u0650 \u062a\u064e\u0646\u0652\u062a\u064e\u0642\u0650\u0644\u064f <code>Fa'ilun Fa'ilun Fa'ilun Fa'ilun</code>"},{"location":"concepts/#3-variations-zihaf-ellah","title":"3. Variations (Zihaf &amp; Ellah)","text":"<p>Poets often deviate from the standard pattern. These deviations are strictly categorized.</p>"},{"location":"concepts/#zihaf-relaxation","title":"Zihaf (Relaxation)","text":"<p>Changes that occur in the \"Hashw\" (internal feet) of the verse. They are usually optional and do not have to be consistent throughout the poem.</p> Name Description Example Khaban Deletion of the 2nd letter. <code>Mustaf'ilun</code> -&gt; <code>Mutaf'ilun</code> Tay Deletion of the 4th letter. <code>Mustaf'ilun</code> -&gt; <code>Musta'ilun</code> Qabadh Deletion of the 5th letter. <code>Fa'ulun</code> -&gt; <code>Fa'ulu</code> Kaff Deletion of the 7th letter. <code>Fa'ilatun</code> -&gt; <code>Fa'ilatu</code> Idmar Quieting the 2nd moved letter. <code>Mutafa'ilun</code> -&gt; <code>Mutfa'ilun</code> (becomes <code>Mustaf'ilun</code>) Asab Quieting the 5th moved letter. <code>Mufa'alatun</code> -&gt; <code>Mufa'altun</code>"},{"location":"concepts/#ellah-defectcause","title":"Ellah (Defect/Cause)","text":"<p>Changes that usually occur in the \"Arudh\" (end of first hemistich) or \"Dharb\" (end of second hemistich). Once applied, they often must be consistent throughout the poem.</p> Name Description Hadhf Removal of the last light syllable (Sabab Khafif). Qataa Cutting the end of a Watad Majmu' and quieting the previous letter. Batr A combination of Hadhf and Qataa (severe reduction). Tatheel Adding a letter to the end (increasing length). Tarfeel Adding a syllable to the end."},{"location":"concepts/#4-pattern-matching-strategy","title":"4. Pattern Matching Strategy","text":"<p>PyArud uses a Greedy Matching strategy to analyze verses.</p> <ol> <li>Identification: It first detects the meter that best fits the overall line.</li> <li>Segmentation: It tries to map the binary string of your verse to the valid feet of that meter.</li> <li>Optimization: If a perfect match isn't found, it looks for the longest valid foot (standard or modified by Zihaf) that matches the current position.</li> <li>Error Reporting:<ul> <li>If it finds text that matches a foot, it marks it <code>ok</code>.</li> <li>If it finds text but it doesn't match any valid variation, it marks it <code>broken</code>.</li> <li>If the verse ends prematurely, it marks the remaining feet as <code>missing</code>.</li> <li>If there are leftover syllables after the verse is complete, it marks them as <code>extra_bits</code>.</li> </ul> </li> </ol>"},{"location":"cookbook/","title":"Cookbook: Common Recipes","text":"<p>This section contains code snippets for common tasks.</p>"},{"location":"cookbook/#1-analyzing-a-text-file-of-poems","title":"1. Analyzing a Text File of Poems","text":"<p>If you have a file <code>poems.txt</code> where each line is <code>Sadr | Ajuz</code>:</p> <pre><code>from pyarud.processor import ArudhProcessor\n\nprocessor = ArudhProcessor()\nverses = []\n\nwith open(\"poems.txt\", \"r\", encoding=\"utf-8\") as f:\n    for line in f:\n        if \"|\" in line:\n            parts = line.split(\"|\")\n            verses.append((parts[0].strip(), parts[1].strip()))\n\nresult = processor.process_poem(verses)\nprint(f\"Detected Meter for file: {result['meter']}\")\n</code></pre>"},{"location":"cookbook/#2-filtering-by-meter","title":"2. Filtering by Meter","text":"<p>How to find only lines that match the \"Wafir\" meter from a list.</p> <pre><code>all_verses = [...] # Large list of verses\nwafir_verses = []\n\nfor s, a in all_verses:\n    res = processor.process_poem([(s, a)])\n    if res['meter'] == 'wafer':\n        wafir_verses.append((s, a))\n</code></pre>"},{"location":"cookbook/#3-getting-raw-binary-patterns","title":"3. Getting Raw Binary Patterns","text":"<p>Sometimes you just want the <code>10110</code> string for your own machine learning model or analysis.</p> <pre><code>from pyarud.arudi import ArudiConverter\n\nconverter = ArudiConverter()\ntext = \"\u0645\u064f\u0633\u0652\u062a\u064e\u0641\u0652\u0639\u0650\u0644\u064f\u0646\u0652\"\n_, pattern = converter.prepare_text(text)\nprint(pattern) # 1010110\n</code></pre>"},{"location":"cookbook/#4-handling-single-hemistich-lines-mashtoor","title":"4. Handling Single-Hemistich Lines (Mashtoor)","text":"<p>Some poems or educational texts only have one hemistich.</p> <pre><code># Pass an empty string for the Ajuz\nresult = processor.process_poem([(\"\u0634\u064e\u0637\u0652\u0631\u064c \u0648\u064e\u0627\u062d\u0650\u062f\u064c \u0641\u064e\u0642\u064e\u0637\u0652\", \"\")])\n\n# The result will contain analysis for Sadr, and Ajuz will be None/Empty\nprint(result['verses'][0]['ajuz_analysis']) # None\n</code></pre>"},{"location":"installation/","title":"Installation Guide","text":""},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<p>PyArud requires Python 3.12 or newer.</p>"},{"location":"installation/#standard-installation","title":"Standard Installation","text":"<p>You can install PyArud directly from PyPI using pip:</p> <pre><code>pip install pyarud\n</code></pre>"},{"location":"installation/#development-setup","title":"Development Setup","text":"<p>If you want to contribute to PyArud or run the tests locally, follow these steps.</p>"},{"location":"installation/#using-standard-venv","title":"Using standard venv","text":"<ol> <li> <p>Clone the repository: <code>bash     git clone https://github.com/yourusername/pyarud.git     cd pyarud</code></p> </li> <li> <p>Create a virtual environment: <code>bash     python3.12 -m venv .venv     source .venv/bin/activate  # On Windows: .venv\\Scripts\\activate</code></p> </li> <li> <p>Install in editable mode with dev dependencies: <code>bash     pip install -e \".[dev,docs]\"</code></p> </li> </ol>"},{"location":"installation/#using-uv-recommended","title":"Using uv (Recommended)","text":"<p>If you use uv, it handles Python versions and virtual environments automatically.</p> <pre><code>uv venv\nsource .venv/bin/activate\nuv pip install -e \".[dev,docs]\"\n</code></pre>"},{"location":"installation/#verifying-installation","title":"Verifying Installation","text":"<p>To verify that PyArud is installed correctly, run this simple one-liner in your terminal:</p> <pre><code>python -c \"from pyarud.processor import ArudhProcessor; print(ArudhProcessor().process_poem([('\u0623\u064e\u062e\u0650\u064a \u062c\u064e\u0627\u0648\u064e\u0632\u064e \u0627\u0644\u0638\u0651\u064e\u0627\u0644\u0650\u0645\u064f\u0648\u0646\u064e \u0627\u0644\u0652\u0645\u064e\u062f\u064e\u0649', '')])['meter'])\"\n</code></pre> <p>It should output:</p> <pre><code>mutakareb\n</code></pre>"},{"location":"meters/","title":"The 16 Meters (\u0627\u0644\u0628\u062d\u0648\u0631 \u0627\u0644\u0633\u062a\u0629 \u0639\u0634\u0631)","text":"<p>The meters of Arabic poetry are grouped into 5 \"Circles\" (Dawa'ir). Al-Khalil discovered that meters in the same circle are actually permutations of the same rhythmic sequence. If you shift the starting point of one meter's pattern, you generate the others in the circle.</p>"},{"location":"meters/#1-dairat-al-mukhtalif","title":"1. Da'irat al-Mukhtalif (\u062f\u0627\u0626\u0631\u0629 \u0627\u0644\u0645\u062e\u062a\u0644\u0641)","text":"<p>The Circle of the Differing - Named because its feet differ in length (some 5-letter, some 7-letter).</p>"},{"location":"meters/#a-al-tawil","title":"A. Al-Tawil (\u0627\u0644\u0628\u062d\u0631 \u0627\u0644\u0637\u0648\u064a\u0644)","text":"<p>\"The Long\" - Named for its length; it is the longest meter in usage. It is the most dignified and widely used meter in classical poetry (Mu'allaqat).</p> <ul> <li>Key (Muftah): <p>\u0637\u064e\u0648\u0650\u064a\u0644\u064c \u0644\u064e\u0647\u064f \u062f\u064f\u0648\u0646\u064e \u0627\u0644\u0652\u0628\u064f\u062d\u064f\u0648\u0631\u0650 \u0641\u064e\u0636\u064e\u0627\u0626\u0650\u0644\u064f *** \u0641\u064e\u0639\u064f\u0648\u0644\u064f\u0646\u0652 \u0645\u064e\u0641\u064e\u0627\u0639\u0650\u064a\u0644\u064f\u0646\u0652 \u0641\u064e\u0639\u064f\u0648\u0644\u064f\u0646\u0652 \u0645\u064e\u0641\u064e\u0627\u0639\u0650\u064a\u0644\u064f\u0646\u0652</p> </li> <li>Standard Pattern: <code>Fa'ulun Mafa'ilun Fa'ulun Mafa'ilun</code> (x2)</li> <li>Binary: <code>11010 1101010 11010 1101010</code></li> <li>Usage: Never used in Majzoo (shortened) form. Always full.</li> <li>Common Zihafs:</li> <li>Qabadh: <code>Fa'ulun</code> (11010) -&gt; <code>Fa'ulu</code> (1101). Very common, especially in the Hashw.</li> <li>Kaff: <code>Mafa'ilun</code> (1101010) -&gt; <code>Mafa'ilu</code> (110101). Rare.</li> <li>Arudh &amp; Dharb:</li> <li>Salima (Healthy): Arudh <code>Mafa'ilun</code> / Dharb <code>Mafa'ilun</code>. (Rare).</li> <li>Maqbudha (Contracted): Arudh <code>Mafa'ilun</code> -&gt; <code>Mafa'ilun</code> (Qabadh) / Dharb <code>Mafa'ilun</code>. (Most Common).</li> <li>Mahdhufa (Deleted): Dharb <code>Mafa'ilun</code> -&gt; <code>Mafa'il</code> (<code>Fa'ulun</code>).</li> </ul>"},{"location":"meters/#b-al-madid","title":"B. Al-Madid (\u0627\u0644\u0628\u062d\u0631 \u0627\u0644\u0645\u062f\u064a\u062f)","text":"<p>\"The Extended\" - Named because the Sababs are extended in its feet. Rare in classical poetry.</p> <ul> <li>Key: <p>\u0644\u0650\u0645\u064e\u062f\u0650\u064a\u062f\u0650 \u0627\u0644\u0634\u0651\u0650\u0639\u0652\u0631\u0650 \u0639\u0650\u0646\u0652\u062f\u0650\u064a \u0635\u0650\u0641\u064e\u0627\u062a\u064f *** \u0641\u064e\u0627\u0639\u0650\u0644\u0627\u062a\u064f\u0646\u0652 \u0641\u064e\u0627\u0639\u0650\u0644\u064f\u0646\u0652 \u0641\u064e\u0627\u0639\u0650\u0644\u0627\u062a\u064f\u0646\u0652</p> </li> <li>Standard Pattern: <code>Fa'ilatun Fa'ilun Fa'ilatun</code> (x2)</li> <li>Binary: <code>1011010 10110 1011010</code></li> <li>Usage: Often used Majzoo (missing the last foot of standard circle pattern).</li> <li>Common Zihafs: Khaban (<code>Fa'ilatun</code> -&gt; <code>Fa'ilatun</code>), Qabadh (<code>Fa'ilun</code> -&gt; <code>Fa'il</code>).</li> </ul>"},{"location":"meters/#c-al-basit","title":"C. Al-Basit (\u0627\u0644\u0628\u062d\u0631 \u0627\u0644\u0628\u0633\u064a\u0637)","text":"<p>\"The Expanded\" - Named for the expansion of its Sababs. Very popular.</p> <ul> <li>Key: <p>\u0625\u0650\u0646\u0651\u064e \u0627\u0644\u0652\u0628\u064e\u0633\u0650\u064a\u0637\u064e \u0644\u064e\u062f\u064e\u064a\u0652\u0647\u0650 \u064a\u064f\u0628\u0652\u0633\u064e\u0637\u064f \u0627\u0644\u0652\u0623\u064e\u0645\u064e\u0644\u064f *** \u0645\u064f\u0633\u0652\u062a\u064e\u0641\u0652\u0639\u0650\u0644\u064f\u0646\u0652 \u0641\u064e\u0627\u0639\u0650\u0644\u064f\u0646\u0652 \u0645\u064f\u0633\u0652\u062a\u064e\u0641\u0652\u0639\u0650\u0644\u064f\u0646\u0652 \u0641\u064e\u0627\u0639\u0650\u0644\u064f\u0646\u0652</p> </li> <li>Standard Pattern: <code>Mustaf'ilun Fa'ilun Mustaf'ilun Fa'ilun</code> (x2)</li> <li>Binary: <code>1010110 10110 1010110 10110</code></li> <li>Common Zihafs:</li> <li>Khaban: <code>Mustaf'ilun</code> -&gt; <code>Mutaf'ilun</code>. <code>Fa'ilun</code> -&gt; <code>Fa'ilun</code>. (Very common).</li> <li>Tay: <code>Mustaf'ilun</code> -&gt; <code>Musta'ilun</code>.</li> <li>Variations:</li> <li>Tam (Full): Standard.</li> <li>Majzoo: <code>Mustaf'ilun Fa'ilun Mustaf'ilun</code> (x2).</li> <li>Mukhalla: A variation of Majzoo with specific heavy defects.</li> </ul>"},{"location":"meters/#2-dairat-al-mutalif","title":"2. Da'irat al-Mu'talif (\u062f\u0627\u0626\u0631\u0629 \u0627\u0644\u0645\u0624\u062a\u0644\u0641)","text":"<p>The Circle of the Agreeing - Feet consist of 7 letters each. Uses the Fasila (<code>///o</code>).</p>"},{"location":"meters/#a-al-wafir","title":"A. Al-Wafir (\u0627\u0644\u0628\u062d\u0631 \u0627\u0644\u0648\u0627\u0641\u0631)","text":"<p>\"The Abundant\" - Very common. Known for its musicality due to the <code>Mufa'alatun</code> foot.</p> <ul> <li>Key: <p>\u0628\u064f\u062d\u064f\u0648\u0631\u064f \u0627\u0644\u0634\u0651\u0650\u0639\u0652\u0631\u0650 \u0648\u064e\u0627\u0641\u0650\u0631\u064f\u0647\u064e\u0627 \u062c\u064e\u0645\u0650\u064a\u0644\u064f *** \u0645\u064f\u0641\u064e\u0627\u0639\u064e\u0644\u064e\u062a\u064f\u0646\u0652 \u0645\u064f\u0641\u064e\u0627\u0639\u064e\u0644\u064e\u062a\u064f\u0646\u0652 \u0641\u064e\u0639\u064f\u0648\u0644\u064f\u0646\u0652</p> </li> <li>Standard Pattern: <code>Mufa'alatun Mufa'alatun Fa'ulun</code> (x2)</li> <li>Binary: <code>1101110 1101110 11010</code></li> <li>Note: The last foot is actually <code>Mufa'alatun</code> reduced to <code>Mufa'al</code> -&gt; <code>Fa'ulun</code>.</li> <li>Common Zihafs:</li> <li>Asab: <code>Mufa'alatun</code> (1101110) -&gt; <code>Mufa'altun</code> (1101010) -&gt; <code>Mafa'ilun</code>. This turns the Wafir rhythm into something resembling Hazaj.</li> </ul>"},{"location":"meters/#b-al-kamil","title":"B. Al-Kamil (\u0627\u0644\u0628\u062d\u0631 \u0627\u0644\u0643\u0627\u0645\u0644)","text":"<p>\"The Perfect\" - Named for its \"perfection\" in having 30 movements in its full form, more than any other.</p> <ul> <li>Key: <p>\u0643\u064e\u0645\u064f\u0644\u064e \u0627\u0644\u0652\u062c\u064e\u0645\u064e\u0627\u0644\u064f \u0645\u0650\u0646\u064e \u0627\u0644\u0652\u0628\u064f\u062d\u064f\u0648\u0631\u0650 \u0627\u0644\u0652\u0643\u064e\u0627\u0645\u0650\u0644\u064f *** \u0645\u064f\u062a\u064e\u0641\u064e\u0627\u0639\u0650\u0644\u064f\u0646\u0652 \u0645\u064f\u062a\u064e\u0641\u064e\u0627\u0639\u0650\u0644\u064f\u0646\u0652 \u0645\u064f\u062a\u064e\u0641\u064e\u0627\u0639\u0650\u0644\u064f\u0646\u0652</p> </li> <li>Standard Pattern: <code>Mutafa'ilun Mutafa'ilun Mutafa'ilun</code> (x2)</li> <li>Binary: <code>1110110 1110110 1110110</code></li> <li>Common Zihafs:</li> <li>Idmar: <code>Mutafa'ilun</code> (1110110) -&gt; <code>Mutfa'ilun</code> (1010110). This makes the foot identical to <code>Mustaf'ilun</code> (Rajaz).</li> <li>Rule: If a verse uses <code>Mutafa'ilun</code> even once, it is Kamil. If it is purely <code>Mustaf'ilun</code>, it is Rajaz.</li> </ul>"},{"location":"meters/#3-dairat-al-mujtalab","title":"3. Da'irat al-Mujtalab (\u062f\u0627\u0626\u0631\u0629 \u0627\u0644\u0645\u062c\u062a\u0644\u0628)","text":"<p>The Circle of the Imported - Uses the Sabab Khafif heavily.</p>"},{"location":"meters/#a-al-hazaj","title":"A. Al-Hazaj (\u0627\u0644\u0628\u062d\u0631 \u0627\u0644\u0647\u0632\u062c)","text":"<p>\"The Trilling\" - Used for songs and light poetry.</p> <ul> <li>Key: <p>\u0639\u064e\u0644\u064e\u0649 \u0627\u0644\u0652\u0623\u064e\u0647\u0652\u0632\u064e\u0627\u062c\u0650 \u062a\u064e\u0633\u0652\u0647\u0650\u064a\u0644\u064f *** \u0645\u064e\u0641\u064e\u0627\u0639\u0650\u064a\u0644\u064f\u0646\u0652 \u0645\u064e\u0641\u064e\u0627\u0639\u0650\u064a\u0644\u064f\u0646\u0652</p> </li> <li>Standard Pattern: <code>Mafa'ilun Mafa'ilun</code> (x2) (Majzoo by nature).</li> </ul>"},{"location":"meters/#b-al-rajaz","title":"B. Al-Rajaz (\u0627\u0644\u0628\u062d\u0631 \u0627\u0644\u0631\u062c\u0632)","text":"<p>\"The Trembling\" (like a camel's leg). The \"Donkey of the Poets\" because it is easy to ride (compose).</p> <ul> <li>Key: <p>\u0641\u0650\u064a \u0623\u064e\u0628\u0652\u062d\u064f\u0631\u0650 \u0627\u0644\u0652\u0623\u064e\u0631\u0652\u062c\u064e\u0627\u0632\u0650 \u0628\u064e\u062d\u0652\u0631\u064c \u064a\u064e\u0633\u0652\u0647\u064f\u0644\u064f *** \u0645\u064f\u0633\u0652\u062a\u064e\u0641\u0652\u0639\u0650\u0644\u064f\u0646\u0652 \u0645\u064f\u0633\u0652\u062a\u064e\u0641\u0652\u0639\u0650\u0644\u064f\u0646\u0652 \u0645\u064f\u0633\u0652\u062a\u064e\u0641\u0652\u0639\u0650\u0644\u064f\u0646\u0652</p> </li> <li>Standard Pattern: <code>Mustaf'ilun Mustaf'ilun Mustaf'ilun</code> (x2)</li> <li>Forms:</li> <li>Tam: 3 feet per line (x2).</li> <li>Majzoo: 2 feet per line (x2).</li> <li>Mashtoor: 3 feet total (1 hemistich).</li> <li>Manhook: 2 feet total (1/3 of a line).</li> </ul>"},{"location":"meters/#c-al-ramal","title":"C. Al-Ramal (\u0627\u0644\u0628\u062d\u0631 \u0627\u0644\u0631\u0645\u0644)","text":"<p>\"The Trotting\". Soft and lyrical.</p> <ul> <li>Key: <p>\u0631\u064e\u0645\u064e\u0644\u064f \u0627\u0644\u0652\u0623\u064e\u0628\u0652\u062d\u064f\u0631\u0650 \u064a\u064e\u0631\u0652\u0648\u0650\u064a\u0647\u0650 \u0627\u0644\u062b\u0651\u0650\u0642\u064e\u0627\u062a\u064f *** \u0641\u064e\u0627\u0639\u0650\u0644\u0627\u062a\u064f\u0646\u0652 \u0641\u064e\u0627\u0639\u0650\u0644\u0627\u062a\u064f\u0646\u0652 \u0641\u064e\u0627\u0639\u0650\u0644\u0627\u062a\u064f\u0646\u0652</p> </li> <li>Standard Pattern: <code>Fa'ilatun Fa'ilatun Fa'ilatun</code> (x2)</li> <li>Common Zihafs: Khaban (<code>Fa'ilatun</code> -&gt; <code>Fa'ilatun</code> 1011010 -&gt; 1101010).</li> </ul>"},{"location":"meters/#4-dairat-al-mushtabah","title":"4. Da'irat al-Mushtabah (\u062f\u0627\u0626\u0631\u0629 \u0627\u0644\u0645\u0634\u062a\u0628\u0647)","text":"<p>The Circle of the Confused - Named because its meters resemble each other and are hard to distinguish. Uses <code>Mustaf'i Lun</code> and <code>Fa'i Latun</code> (split feet).</p>"},{"location":"meters/#a-al-saree","title":"A. Al-Saree (\u0627\u0644\u0628\u062d\u0631 \u0627\u0644\u0633\u0631\u064a\u0639)","text":"<p>\"The Fast\".</p> <ul> <li>Key: <p>\u0628\u064e\u062d\u0652\u0631\u064c \u0633\u064e\u0631\u0650\u064a\u0639\u064c \u0645\u064e\u0627 \u0644\u064e\u0647\u064f \u0633\u064e\u0627\u062d\u0650\u0644\u064f *** \u0645\u064f\u0633\u0652\u062a\u064e\u0641\u0652\u0639\u0650\u0644\u064f\u0646\u0652 \u0645\u064f\u0633\u0652\u062a\u064e\u0641\u0652\u0639\u0650\u0644\u064f\u0646\u0652 \u0641\u0627\u0639\u0650\u0644\u064f\u0646\u0652</p> </li> <li>Note: The last foot <code>Maf'ulatu</code> is folded (<code>Tay</code>) to <code>Fa'ilun</code>.</li> </ul>"},{"location":"meters/#b-al-munsarih","title":"B. Al-Munsarih (\u0627\u0644\u0628\u062d\u0631 \u0627\u0644\u0645\u0646\u0633\u0631\u062d)","text":"<p>\"The Flowing\".</p> <ul> <li>Key: <p>\u0645\u064f\u0646\u0652\u0633\u064e\u0631\u0650\u062d\u064c \u0641\u0650\u064a\u0647\u0650 \u064a\u064f\u0636\u0652\u0631\u064e\u0628\u064f \u0627\u0644\u0652\u0645\u064e\u062b\u064e\u0644\u064f *** \u0645\u064f\u0633\u0652\u062a\u064e\u0641\u0652\u0639\u0650\u0644\u064f\u0646\u0652 \u0645\u064e\u0641\u0652\u0639\u064f\u0648\u0644\u0627\u062a\u064f \u0645\u064f\u0633\u0652\u062a\u064e\u0641\u0652\u0639\u0650\u0644\u064f\u0646\u0652</p> </li> </ul>"},{"location":"meters/#c-al-khafif","title":"C. Al-Khafif (\u0627\u0644\u0628\u062d\u0631 \u0627\u0644\u062e\u0641\u064a\u0641)","text":"<p>\"The Light\". Very popular for philosophical and refined poetry.</p> <ul> <li>Key: <p>\u064a\u064e\u0627 \u062e\u064e\u0641\u0650\u064a\u0641\u0627\u064b \u062e\u064e\u0641\u0651\u064e\u062a\u0652 \u0628\u0650\u0647\u0650 \u0627\u0644\u0652\u062d\u064e\u0631\u064e\u0643\u064e\u0627\u062a\u064f *** \u0641\u064e\u0627\u0639\u0650\u0644\u0627\u062a\u064f\u0646\u0652 \u0645\u064f\u0633\u0652\u062a\u064e\u0641\u0652\u0639\u0650 \u0644\u064f\u0646\u0652 \u0641\u064e\u0627\u0639\u0650\u0644\u0627\u062a\u064f\u0646\u0652</p> </li> </ul>"},{"location":"meters/#d-al-mudhari","title":"D. Al-Mudhari (\u0627\u0644\u0628\u062d\u0631 \u0627\u0644\u0645\u0636\u0627\u0631\u0639)","text":"<p>\"The Similar\" (to Munasrih). Rare.</p> <ul> <li>Key: <code>Mafa'ilun Fa'i Latun</code></li> </ul>"},{"location":"meters/#e-al-muqtadhib","title":"E. Al-Muqtadhib (\u0627\u0644\u0628\u062d\u0631 \u0627\u0644\u0645\u0642\u062a\u0636\u0628)","text":"<p>\"The Cut Off\". Rare.</p> <ul> <li>Key: <code>Maf'ulatu Mustaf'ilun</code></li> </ul>"},{"location":"meters/#f-al-mujtath","title":"F. Al-Mujtath (\u0627\u0644\u0628\u062d\u0631 \u0627\u0644\u0645\u062c\u062a\u062b)","text":"<p>\"The Uprooted\".</p> <ul> <li>Key: <code>Mustaf'i Lun Fa'ilatun</code></li> </ul>"},{"location":"meters/#5-dairat-al-muttafiq","title":"5. Da'irat al-Muttafiq (\u062f\u0627\u0626\u0631\u0629 \u0627\u0644\u0645\u062a\u0641\u0642)","text":"<p>The Circle of the Agreed - Meters built from a single 5-letter foot repeated.</p>"},{"location":"meters/#a-al-mutaqarib","title":"A. Al-Mutaqarib (\u0627\u0644\u0628\u062d\u0631 \u0627\u0644\u0645\u062a\u0642\u0627\u0631\u0628)","text":"<p>\"The Near\".</p> <ul> <li>Key: <p>\u0639\u064e\u0646\u0650 \u0627\u0644\u0652\u0645\u064f\u062a\u064e\u0642\u064e\u0627\u0631\u0650\u0628\u0650 \u0642\u064e\u0627\u0644\u064e \u0627\u0644\u0652\u062e\u064e\u0644\u0650\u064a\u0644\u064f *** \u0641\u064e\u0639\u064f\u0648\u0644\u064f\u0646\u0652 \u0641\u064e\u0639\u064f\u0648\u0644\u064f\u0646\u0652 \u0641\u064e\u0639\u064f\u0648\u0644\u064f\u0646\u0652 \u0641\u064e\u0639\u064f\u0648\u0644\u064f\u0646\u0652</p> </li> <li>Standard Pattern: <code>Fa'ulun</code> x4 (x2).</li> <li>Common Variations:</li> <li>Hadhf: Last foot becomes <code>Fa'u</code> (110).</li> <li>Batar: Last foot becomes <code>Fa'</code> (10).</li> </ul>"},{"location":"meters/#b-al-mutadarak","title":"B. Al-Mutadarak (\u0627\u0644\u0628\u062d\u0631 \u0627\u0644\u0645\u062a\u062f\u0627\u0631\u0643)","text":"<p>\"The Overtaken\". Also called Al-Khabab (The Trot of the Horse). Discovered by Al-Akhfash.</p> <ul> <li>Key: <p>\u062d\u064e\u0631\u064e\u0643\u064e\u0627\u062a\u064f \u0627\u0644\u0652\u0645\u064f\u062d\u0652\u062f\u064e\u062b\u0650 \u062a\u064e\u0646\u0652\u062a\u064e\u0642\u0650\u0644\u064f *** \u0641\u064e\u0627\u0639\u0650\u0644\u064f\u0646\u0652 \u0641\u064e\u0627\u0639\u0650\u0644\u064f\u0646\u0652 \u0641\u064e\u0627\u0639\u0650\u0644\u064f\u0646\u0652 \u0641\u064e\u0627\u0639\u0650\u0644\u064f\u0646\u0652</p> </li> <li>Standard Pattern: <code>Fa'ilun</code> x4 (x2).</li> <li>The Khabab Rhythm: Heavily uses Khaban (<code>Fa'ilun</code> -&gt; <code>Fa'ilun</code> 11010). When the whole poem is <code>11010</code>, it sounds like a galloping horse (Khabab).</li> </ul>"},{"location":"quickstart/","title":"Quick Start","text":"<p>This guide will get you analyzing Arabic poetry in under 5 minutes.</p>"},{"location":"quickstart/#1-basic-analysis","title":"1. Basic Analysis","text":"<p>The primary entry point is the <code>ArudhProcessor</code>.</p> <pre><code>from pyarud.processor import ArudhProcessor\n\n# 1. Initialize\nprocessor = ArudhProcessor()\n\n# 2. Define your verse (Sadr, Ajuz)\nverse = (\"\u0623\u064e\u062e\u0650\u064a \u062c\u064e\u0627\u0648\u064e\u0632\u064e \u0627\u0644\u0638\u0651\u064e\u0627\u0644\u0650\u0645\u064f\u0648\u0646\u064e \u0627\u0644\u0652\u0645\u064e\u062f\u064e\u0649\", \"\u0641\u064e\u062d\u064e\u0642\u0651\u064e \u0627\u0644\u0652\u062c\u0650\u0647\u064e\u0627\u062f\u064f \u0648\u064e\u062d\u064e\u0642\u0651\u064e \u0627\u0644\u0652\u0641\u0650\u062f\u064e\u0627\")\n\n# 3. Process\n# The input must be a list of tuples\nresult = processor.process_poem([verse])\n\n# 4. Print Result\nprint(f\"Meter: {result['meter']}\")\n</code></pre>"},{"location":"quickstart/#2-interpreting-the-result","title":"2. Interpreting the Result","text":"<p>The <code>result</code> is a rich dictionary containing detailed information about every foot in the verse.</p> <pre><code>{\n  \"meter\": \"mutakareb\",\n  \"verses\": [\n    {\n      \"verse_index\": 0,\n      \"score\": 1.0,\n      \"sadr_analysis\": [\n        {\n           \"foot_index\": 0,\n           \"status\": \"ok\",\n           \"expected_pattern\": \"11010\",\n           \"actual_segment\": \"11010\",\n           \"score\": 1.0\n        },\n        # ... more feet\n      ],\n      \"ajuz_analysis\": [...]\n    }\n  ]\n}\n</code></pre>"},{"location":"quickstart/#3-batch-processing","title":"3. Batch Processing","text":"<p>You can analyze an entire poem at once. The processor will determine the global meter based on the majority of verses.</p> <pre><code>poem = [\n    (\"\u0623\u064e\u062e\u0650\u064a \u062c\u064e\u0627\u0648\u064e\u0632\u064e \u0627\u0644\u0638\u0651\u064e\u0627\u0644\u0650\u0645\u064f\u0648\u0646\u064e \u0627\u0644\u0652\u0645\u064e\u062f\u064e\u0649\", \"\u0641\u064e\u062d\u064e\u0642\u0651\u064e \u0627\u0644\u0652\u062c\u0650\u0647\u064e\u0627\u062f\u064f \u0648\u064e\u062d\u064e\u0642\u0651\u064e \u0627\u0644\u0652\u0641\u0650\u062f\u064e\u0627\"),\n    (\"\u0639\u064e\u0644\u064e\u0627\u0645\u064e \u0627\u0644\u062a\u0651\u064e\u0639\u064e\u0644\u0651\u064f\u0644\u064f \u0628\u0650\u0627\u0644\u0652\u0622\u0645\u064e\u0627\u0644\u0650\", \"\u0648\u064e\u0645\u064e\u0627 \u0632\u0650\u0644\u0652\u062a\u064f \u0641\u0650\u064a \u063a\u064e\u0641\u0652\u0644\u064e\u0629\u064d \u0631\u064e\u0627\u0642\u0650\u062f\u064e\u0627\"),  # Intentionally different/broken for demo\n]\n\nresult = processor.process_poem(poem)\n\nprint(f\"Global Meter: {result['meter']}\")\nfor v in result['verses']:\n    print(f\"Verse {v['verse_index'] + 1} Score: {v['score']}\")\n</code></pre>"},{"location":"quickstart/#4-handling-input-text","title":"4. Handling Input Text","text":"<p>PyArud works best with fully diacritized text (Shakl).</p> <ul> <li>With Diacritics: <code>\u0643\u064e\u062a\u064e\u0628\u064e</code> -&gt; Detected as <code>111</code> (Mutaharrik, Mutaharrik, Mutaharrik).</li> <li>Without Diacritics: <code>\u0643\u062a\u0628</code> -&gt; PyArud has to guess or treat letters as Mutaharrik by default, which may lead to inaccurate results.</li> </ul> <p>Tip: If you are building an app, consider using a Tashkeel (diacritization) library like <code>mishkal</code> or <code>tashaphyne</code> before passing text to PyArud.</p>"},{"location":"zihafs/","title":"Modifications: Zihafs and Ellals (\u0627\u0644\u0632\u062d\u0627\u0641\u0627\u062a \u0648\u0627\u0644\u0639\u0644\u0644)","text":"<p>In Arabic Prosody, the standard feet (Taf'ilas) are ideal templates. Real poetry often modifies these templates for musical variation or necessity. These modifications are strictly categorized into Zihafs and Ellals.</p>"},{"location":"zihafs/#1-zihaf","title":"1. Zihaf (\u0627\u0644\u0632\u062d\u0627\u0641)","text":"<p>Definition: A change that affects the Sabab (Cord) letters in the foot. - Scope: Can occur in the Hashw (interior feet), Arudh (end of 1st hemistich), or Dharb (end of 2nd hemistich). - Consistency: Generally not binding (Ghayr Lazim). If a poet uses a Zihaf in one verse, they are not required to use it in the next (with some exceptions).</p>"},{"location":"zihafs/#single-zihafs","title":"Single Zihafs (\u0627\u0644\u0632\u062d\u0627\u0641 \u0627\u0644\u0645\u0641\u0631\u062f)","text":"<p>Changes involving only one letter.</p> Name (Arabic) Name (English) Definition Effect Example \u0627\u0644\u0625\u0650\u0636\u0652\u0645\u064e\u0627\u0631 Idmar Quieting the 2nd letter. <code>11...</code> $\\rightarrow$ <code>10...</code> <code>Mutafa'ilun</code> $\\rightarrow$ <code>Mutfa'ilun</code> \u0627\u0644\u0652\u062e\u064e\u0628\u0652\u0646 Khaban Deletion of the 2nd letter. <code>10...</code> $\\rightarrow$ <code>1...</code> <code>Mustaf'ilun</code> $\\rightarrow$ <code>Mutaf'ilun</code> \u0627\u0644\u0652\u0648\u064e\u0642\u0652\u0635 Waqas Deletion of the 2nd letter (if moving). <code>11...</code> $\\rightarrow$ <code>1...</code> <code>Mutafa'ilun</code> $\\rightarrow$ <code>Mufa'ilun</code> \u0627\u0644\u0637\u0651\u064e\u064a Tay Deletion of the 4th letter. <code>...10...</code> $\\rightarrow$ <code>...1...</code> <code>Mustaf'ilun</code> $\\rightarrow$ <code>Musta'ilun</code> \u0627\u0644\u0652\u0639\u064e\u0635\u0652\u0628 Asab Quieting the 5th letter. <code>...11...</code> $\\rightarrow$ <code>...10...</code> <code>Mufa'alatun</code> $\\rightarrow$ <code>Mufa'altun</code> \u0627\u0644\u0652\u0642\u064e\u0628\u0652\u0636 Qabadh Deletion of the 5th letter. <code>...10...</code> $\\rightarrow$ <code>...1...</code> <code>Fa'ulun</code> $\\rightarrow$ <code>Fa'ulu</code> \u0627\u0644\u0652\u0639\u064e\u0642\u0652\u0644 Akal Deletion of the 5th letter (if moving). <code>...11...</code> $\\rightarrow$ <code>...1...</code> <code>Mufa'alatun</code> $\\rightarrow$ <code>Mufa'atun</code> \u0627\u0644\u0652\u0643\u064e\u0641 Kaff Deletion of the 7th letter. <code>...10</code> $\\rightarrow$ <code>...1</code> <code>Fa'ilatun</code> $\\rightarrow$ <code>Fa'ilatu</code>"},{"location":"zihafs/#double-zihafs","title":"Double Zihafs (\u0627\u0644\u0632\u062d\u0627\u0641 \u0627\u0644\u0645\u0632\u062f\u0648\u062c)","text":"<p>Changes involving two letters in the same foot.</p> Name (Arabic) Name (English) Combination Example \u0627\u0644\u0652\u062e\u064e\u0628\u0652\u0644 Khabal Khaban + Tay <code>Mustaf'ilun</code> $\\rightarrow$ <code>Mu'ta'ilun</code> \u0627\u0644\u0652\u062e\u064e\u0632\u0652\u0644 Khazal Idmar + Tay <code>Mutafa'ilun</code> $\\rightarrow$ <code>Mutfa'il</code> \u0627\u0644\u0634\u0651\u064e\u0643\u0652\u0644 Shakal Khaban + Kaff <code>Fa'ilatun</code> $\\rightarrow$ <code>Fa'ilatu</code> \u0627\u0644\u0646\u0651\u064e\u0642\u0652\u0635 Nakas Asab + Kaff <code>Mufa'alatun</code> $\\rightarrow$ <code>Mufa'altu</code>"},{"location":"zihafs/#2-ellah","title":"2. Ellah (\u0627\u0644\u0639\u0644\u0629)","text":"<p>Definition: A change that affects the Watad (Peg) or the ending of the foot. - Scope: Only occurs in the Arudh and Dharb (the ends of hemistiches). - Consistency: Binding (Lazim). Once a poet uses an Ellah in the first verse, they must maintain it throughout the entire poem.</p>"},{"location":"zihafs/#ellal-of-increase","title":"Ellal of Increase (\u0639\u0644\u0644 \u0627\u0644\u0632\u064a\u0627\u062f\u0629)","text":"<p>Adding letters to the foot. Occurs mostly in Majzoo meters.</p> Name (Arabic) Name (English) Definition Example \u0627\u0644\u062a\u0651\u064e\u0631\u0652\u0641\u0650\u064a\u0644 Tarfeel Adding a Sabab Khafif (<code>10</code>) to the end. <code>Fa'ilun</code> $\\rightarrow$ <code>Fa'ilun-tun</code> (<code>Fa'ilatun</code>) \u0627\u0644\u062a\u0651\u064e\u0630\u0652\u064a\u0650\u064a\u0644 Tatheel Adding a Sakin letter to a Watad Majmu'. <code>Fa'ilun</code> $\\rightarrow$ <code>Fa'ilan</code> \u0627\u0644\u062a\u0651\u064e\u0633\u0652\u0628\u0650\u064a\u063a Tasbeegh Adding a Sakin letter to a Sabab Khafif. <code>Fa'ilatun</code> $\\rightarrow$ <code>Fa'ilatan</code>"},{"location":"zihafs/#ellal-of-decrease","title":"Ellal of Decrease (\u0639\u0644\u0644 \u0627\u0644\u0646\u0642\u0635)","text":"<p>Removing letters from the foot.</p> Name (Arabic) Name (English) Definition Example \u0627\u0644\u0652\u062d\u064e\u0630\u0652\u0641 Hadhf Dropping the final Sabab Khafif. <code>Fa'ulun</code> $\\rightarrow$ <code>Fa'u</code> \u0627\u0644\u0652\u0642\u064e\u0637\u0652\u0641 Qataf Dropping Sabab + Asab (Quieting 5th). <code>Mufa'alatun</code> $\\rightarrow$ <code>Fa'ulun</code> \u0627\u0644\u0652\u0642\u064e\u0637\u0652\u0639 Qataa Cutting the tail of Watad Majmu' &amp; quieting predecessor. <code>Fa'ilun</code> $\\rightarrow$ <code>Fa'il</code> \u0627\u0644\u0652\u0628\u064e\u062a\u0652\u0631 Batr Hadhf + Qataa (Extremity). <code>Fa'ulun</code> $\\rightarrow$ <code>Fa</code> \u0627\u0644\u0652\u0642\u064e\u0635\u0652\u0631 Qasar Dropping the Sakin of Sabab Khafif &amp; quieting the mover. <code>Fa'ilatun</code> $\\rightarrow$ <code>Fa'ilat</code> \u0627\u0644\u0652\u062d\u064e\u0630\u064e\u0630 Hathath Dropping a full Watad Majmu'. <code>Mutafa'ilun</code> $\\rightarrow$ <code>Mutfa</code> \u0627\u0644\u0635\u0651\u064e\u0644\u0652\u0645 Salam Dropping a full Watad Mafruq. <code>Maf'ulatu</code> $\\rightarrow$ <code>Maf'u</code> \u0627\u0644\u0652\u0643\u064e\u0634\u0652\u0641 Kashf/Kasf Dropping the last letter of a Watad Mafruq. <code>Maf'ulatu</code> $\\rightarrow$ <code>Maf'ula</code> \u0627\u0644\u0652\u0648\u064e\u0642\u0652\u0641 Waqf Quieting the last letter of a Watad Mafruq. <code>Maf'ulatu</code> $\\rightarrow$ <code>Maf'ulat</code>"},{"location":"zihafs/#3-how-pyarud-validates-modifications","title":"3. How PyArud Validates Modifications","text":"<p>PyArud does not just \"guess\" modifications. Each <code>Tafeela</code> class in the code has a list of <code>allowed_zehafs</code>.</p> <p>For example, <code>Mustafelon</code> allows <code>Khaban</code> and <code>Tay</code>. When analyzing a verse, PyArud generates all mathematically valid permutations of <code>Mustafelon</code> (e.g., <code>1010110</code>, <code>110110</code>, <code>101010</code>) and tries to match them against your text.</p> <p>If a modification is found, the analysis result will explicitly state the <code>status</code> and the expected pattern versus the actual segment, allowing you to trace exactly which rule was applied.</p>"},{"location":"theory/components/","title":"The Foundation: Components (\u0627\u0644\u0623\u0631\u0643\u0627\u0646 \u0648\u0627\u0644\u062a\u0641\u0627\u0639\u064a\u0644)","text":"<p>Arabic prosody is built on a binary system. Every sound is either moving or still. These atoms combine to form molecules (Sabab, Watad), which combine to form the DNA of the verse (Taf'ila).</p>"},{"location":"theory/components/#1-the-atoms-haraka-and-sukun","title":"1. The Atoms: Haraka and Sukun","text":"<ul> <li>Haraka (Movement - / or 1): A letter with a vowel (Fatha, Damma, Kasra).<ul> <li>Example: The 'K' in Ka-taba (\u0643\u064e).</li> </ul> </li> <li>Sukun (Stillness - o or 0): A letter with no vowel, or a long vowel (Alif, Waw, Ya).<ul> <li>Example: The 'L' in Qul (\u0642\u064f\u0644\u0652), or the 'A' in Qaala (\u0642\u064e\u0627\u0644\u064e).</li> </ul> </li> </ul> <p>In PyArud, we represent these digitally as <code>1</code> (Haraka) and <code>0</code> (Sukun).</p>"},{"location":"theory/components/#2-the-molecules-roots","title":"2. The Molecules: Roots (\u0627\u0644\u0623\u0635\u0648\u0644)","text":"<p>These atoms combine to form linguistic units used to build feet. Al-Khalil identified six types:</p>"},{"location":"theory/components/#a-asbab-cords-","title":"A. Asbab (Cords) - \u0627\u0644\u0623\u0633\u0628\u0627\u0628","text":"<p>Named after the rope of a tent. 1.  Sabab Khafif (Light Cord): A moving letter followed by a still one (<code>/o</code> or <code>10</code>).     -   Example: Laml (\u0644\u064e\u0645\u0652), Man (\u0645\u064e\u0646\u0652). 2.  Sabab Thaqil (Heavy Cord): Two moving letters (<code>//</code> or <code>11</code>).     -   Example: Laka (\u0644\u064e\u0643\u064e), Bika (\u0628\u0650\u0643\u064e).</p>"},{"location":"theory/components/#b-awtad-pegs-","title":"B. Awtad (Pegs) - \u0627\u0644\u0623\u0648\u062a\u0627\u062f","text":"<p>Named after the peg used to secure the tent. Pegs are stronger than Cords and rarely suffer from deletion (Zihaf). 3.  Watad Majmu' (Joined Peg): Two moving letters followed by a still one (<code>//o</code> or <code>110</code>).     -   Example: Laqad (\u0644\u064e\u0642\u064e\u062f\u0652), Na'am (\u0646\u064e\u0639\u064e\u0645\u0652).     -   Note: This is the most stable unit in Arabic prosody. 4.  Watad Mafruq (Separated Peg): A moving letter, a still one, then a moving one (<code>/o/</code> or <code>101</code>).     -   Example: Qama (\u0642\u064e\u0627\u0645\u064e) in Qama Zaid (where Z is next). Or Lay-ta (\u0644\u064e\u064a\u0652\u062a\u064e).</p>"},{"location":"theory/components/#c-fawasil-separators-","title":"C. Fawasil (Separators) - \u0627\u0644\u0641\u0648\u0627\u0635\u0644","text":"<ol> <li>Fasila Sughra (Small Separator): Three moving letters followed by a still one (<code>///o</code> or <code>1110</code>).<ul> <li>Example: Jabalun (\u062c\u064e\u0628\u064e\u0644\u064c).</li> <li>Analysis: Effectively a Sabab Thaqil + Sabab Khafif (<code>//</code> + <code>/o</code>).</li> </ul> </li> <li>Fasila Kubra (Large Separator): Four moving letters followed by a still one (<code>////o</code> or <code>11110</code>).<ul> <li>Example: Samakatun (\u0633\u064e\u0645\u064e\u0643\u064e\u0629\u064c).</li> <li>Analysis: Effectively a Sabab Thaqil + Watad Majmu' (<code>//</code> + <code>//o</code>).</li> </ul> </li> </ol>"},{"location":"theory/components/#mnemonic","title":"Mnemonic","text":"<p>Generations of students have memorized these units with the phrase:</p> <p>\u0644\u064e\u0645\u0652 \u0623\u064e\u0631\u064e \u0639\u064e\u0644\u064e\u0649 \u0638\u064e\u0647\u0652\u0631\u0650 \u062c\u064e\u0628\u064e\u0644\u064d \u0633\u064e\u0645\u064e\u0643\u064e\u0629\u064b (Lam Ara 'Ala Zahri Jabalin Samakatan) I have not seen a fish on the back of a mountain.</p> <ul> <li>Lam (<code>/o</code>): Sabab Khafif.</li> <li>Ara (<code>//</code>): Sabab Thaqil.</li> <li>'Ala (<code>//o</code>): Watad Majmu'.</li> <li>Zahri (<code>/o/</code>): Watad Mafruq (ignoring the final Kasra logic for isolation).</li> <li>Jabalin (<code>///o</code>): Fasila Sughra.</li> <li>Samakatan (<code>////o</code>): Fasila Kubra.</li> </ul>"},{"location":"theory/components/#3-the-dna-feet","title":"3. The DNA: Feet (\u0627\u0644\u062a\u0641\u0627\u0639\u064a\u0644)","text":"<p>Al-Khalil combined these molecules into 10 standard \"Feet\" (Taf'ila). These are the templates used to measure verses. They are built from the root word F-'-L (\u0641\u0639\u0644).</p> Taf'ila (Arabic) Taf'ila (English) Pattern Structure Used in Meters \u0641\u064e\u0639\u064f\u0648\u0644\u064f\u0646\u0652 Fa'ulun <code>11010</code> Watad Majmu' + Sabab Khafif Tawil, Mutaqarib, Hazaj \u0645\u064e\u0641\u064e\u0627\u0639\u0650\u064a\u0644\u064f\u0646\u0652 Mafa'ilun <code>1101010</code> Watad Majmu' + 2 Sabab Khafif Hazaj, Tawil, Mudhari \u0645\u064f\u0641\u064e\u0627\u0639\u064e\u0644\u064e\u062a\u064f\u0646\u0652 Mufa'alatun <code>1101110</code> Watad Majmu' + Fasila Sughra Wafir \u0645\u064f\u062a\u064e\u0641\u064e\u0627\u0639\u0650\u0644\u064f\u0646\u0652 Mutafa'ilun <code>1110110</code> Fasila Sughra + Watad Majmu' Kamil \u0641\u064e\u0627\u0639\u0650\u0644\u064f\u0646\u0652 Fa'ilun <code>10110</code> Sabab Khafif + Watad Majmu' Madid, Basit, Mutadarak \u0641\u064e\u0627\u0639\u0650\u0644\u0627\u062a\u064f\u0646\u0652 Fa'ilatun <code>1011010</code> Watad Mafruq + 2 Sabab Khafif Ramal, Madid, Khafif \u0645\u064f\u0633\u0652\u062a\u064e\u0641\u0652\u0639\u0650\u0644\u064f\u0646\u0652 Mustaf'ilun <code>1010110</code> 2 Sabab Khafif + Watad Majmu' Rajaz, Basit, Saree \u0645\u064e\u0641\u0652\u0639\u064f\u0648\u0644\u0627\u062a\u064f Maf'ulatu <code>1010101</code> 2 Sabab Khafif + Watad Mafruq Munsarih, Muqtadhib \u0641\u064e\u0627\u0639\u0650 \u0644\u0627\u062a\u064f\u0646\u0652 Fa'i Latun <code>101 1010</code> Watad Mafruq + 2 Sabab Khafif Mudhari (Split version) \u0645\u064f\u0633\u0652\u062a\u064e\u0641\u0652\u0639\u0650 \u0644\u064f\u0646\u0652 Mustaf'i Lun <code>1010 110</code> 2 Sabab Khafif + Watad Majmu' Khafif, Mujtath (Split version) <p>Note on Split Feet: Some feet like <code>Mustaf'ilun</code> can be effectively the same pattern (<code>1010110</code>), but their internal structure differs depending on the meter. - In Rajaz, it is <code>Sabab, Sabab, Watad</code> (<code>10, 10, 110</code>). - In Khafif, it is <code>Sabab, Watad, Sabab</code> (<code>10, 110, 10</code>), written as <code>Mustaf'i Lun</code>. This distinction is crucial because Zihaf (Deletion) usually only affects Sababs, not Watads. A letter that is the 7th in one version might be part of a protected Watad in another.</p>"},{"location":"theory/introduction/","title":"Introduction to Arabic Prosody (\u0645\u0642\u062f\u0645\u0629 \u0641\u064a \u0639\u0644\u0645 \u0627\u0644\u0639\u0631\u0648\u0636)","text":""},{"location":"theory/introduction/#definition","title":"Definition (\u0627\u0644\u062a\u0639\u0631\u064a\u0641)","text":"<p>Ilm al-Arudh (Arabic: \u0639\u0644\u0645 \u0627\u0644\u0639\u0631\u0648\u0636) is the science of Arabic poetry that studies the rhythmic patterns (meters) and their rules of correctness and variation. It acts as the \"scale\" or \"balance\" used to distinguish correct poetry (Sahih) from broken poetry (Maksur), and to identify the specific type of meter (Bahr) used by the poet.</p> <p>The word Arudh literally means \"side\", \"middle\", or \"pillar\" of a tent, signifying its central role in the structure of the verse. In technical terms, Arudh refers specifically to the last foot of the first hemistich (Sadr) of a verse, but the science as a whole is named after it.</p>"},{"location":"theory/introduction/#history-and-origin","title":"History and Origin (\u0627\u0644\u0646\u0634\u0623\u0629 \u0648\u0627\u0644\u062a\u0627\u0631\u064a\u062e)","text":"<p>The science was founded in the 8th century CE (2nd century AH) by the genius philologist Al-Khalil bin Ahmed Al-Farahidi (\u0627\u0644\u062e\u0644\u064a\u0644 \u0628\u0646 \u0623\u062d\u0645\u062f \u0627\u0644\u0641\u0631\u0627\u0647\u064a\u062f\u064a).</p>"},{"location":"theory/introduction/#the-legend-of-discovery","title":"The Legend of Discovery","text":"<p>It is said that Al-Khalil was walking through the coppersmiths' market (Souq al-Saffarin) in Basra. He heard the rhythmic hammering of the smiths on the copper vessels\u2014DANG, dang, DANG-dang. This repetitive sound inspired him to realize that poetry consists of sequences of moving (Mutaharrik) and still (Sakin) sounds.</p> <p>He secluded himself, studying all available Arabic poetry, and distilled their rhythms into 15 distinct meters. Later, his student Al-Akhfash Al-Awsat discovered a 16th meter, called Al-Mutadarak (The Overtaken), completing the system we use today.</p>"},{"location":"theory/introduction/#the-importance-of-arudh","title":"The Importance of Arudh","text":"<ol> <li>Authentication: It helps verify the attribution of verses. If a poem attributed to a pre-Islamic poet breaks the rules of Arudh known to be instinctive at the time, its authenticity is questioned.</li> <li>Reading: It guides the correct reading of poetry. Often, a word can be read in multiple ways grammatically, but only one reading fits the meter.</li> <li>Composition: It provides the framework for poets to compose rhythmic and musical verses.</li> </ol>"},{"location":"theory/introduction/#the-scope-of-pyarud","title":"The Scope of PyArud","text":"<p>PyArud encapsulates this millennium-old wisdom into a modern computational engine. It respects the classical rules defined by Al-Khalil while providing the precision of digital analysis. By understanding the theory documented in these pages, you will better understand the output and capabilities of the library.</p>"},{"location":"theory/writing/","title":"Arudi Writing (\u0627\u0644\u0643\u062a\u0627\u0628\u0629 \u0627\u0644\u0639\u0631\u0648\u0636\u064a\u0629)","text":"<p>Before a poem can be analyzed mathematically, it must be transcribed from standard orthography (Imla\\'i) to phonetic orthography (Arudi). This is the \"compilation\" step of prosody.</p>"},{"location":"theory/writing/#the-golden-rule","title":"The Golden Rule","text":"<p>\u0645\u0627 \u064a\u064f\u0646\u0652\u0637\u064e\u0642\u064f \u064a\u064f\u0643\u0652\u062a\u064e\u0628\u064f\u060c \u0648\u064e\u0645\u0627 \u0644\u0627 \u064a\u064f\u0646\u0652\u0637\u064e\u0642\u064f \u0644\u0627 \u064a\u064f\u0643\u0652\u062a\u064e\u0628\u064f What is pronounced is written, and what is not pronounced is not written.</p> <p>Arudh does not care about spelling rules, silent letters, or grammar. It cares only about the sound.</p>"},{"location":"theory/writing/#rules-of-addition","title":"Rules of Addition (\u0645\u0627 \u064a\u064f\u0632\u0627\u062f)","text":"<p>Letters that are pronounced but usually hidden in spelling must be made explicit.</p>"},{"location":"theory/writing/#1-tanween-nunation","title":"1. Tanween (Nunation)","text":"<p>The \\'n\\' sound at the end of indefinite nouns is written as a Nun (<code>\u0646</code>). -   Kitabun (\u0643\u0650\u062a\u064e\u0627\u0628\u064c) $\\rightarrow$ Kitabun (\u0643\u0650\u062a\u064e\u0627\u0628\u064f\u0646\u0652). -   School (\u0645\u064e\u062f\u0652\u0631\u064e\u0633\u064e\u0629\u064d) $\\rightarrow$ Madrasatin (\u0645\u064e\u062f\u0652\u0631\u064e\u0633\u064e\u062a\u0650\u0646\u0652).</p>"},{"location":"theory/writing/#2-shadda-gemination","title":"2. Shadda (Gemination)","text":"<p>A doubled letter is written as two letters: the first Sakin (0), the second Mutaharrik (1). -   Madda (\u0645\u064e\u062f\u0651\u064e) $\\rightarrow$ Madda (\u0645\u064e\u062f\u0652\u062f\u064e). -   Shams (\u0627\u0644\u0634\u0651\u064e\u0645\u0652\u0633) $\\rightarrow$ Ash-Shams (\u0627\u0634\u0652\u0634\u064e\u0645\u0652\u0633).</p>"},{"location":"theory/writing/#3-explicit-long-vowels","title":"3. Explicit Long Vowels","text":"<p>Some words have a long \\'A\\' that is pronounced but omitted in standard spelling. PyArud automatically expands these. -   Hatha (\u0647\u0630\u0627) $\\rightarrow$ Haatha (\u0647\u064e\u0627\u0630\u064e\u0627). -   Allah (\u0627\u0644\u0644\u0647) $\\rightarrow$ Allaah (\u0627\u0644\u0644\u0651\u064e\u0627\u0647). -   Lakin (\u0644\u0643\u0646) $\\rightarrow$ Laakin (\u0644\u064e\u0627\u0643\u0650\u0646). -   Taha (\u0637\u0647) $\\rightarrow$ Taaha (\u0637\u064e\u0627\u0647\u064e\u0627).</p>"},{"location":"theory/writing/#4-ashba-saturation","title":"4. Ashba' (Saturation)","text":"<p>The vowel at the end of a hemistich (especially the Rawi or rhyme letter) is often stretched until it becomes a long vowel letter. -   Kitabu (\u0643\u0650\u062a\u064e\u0627\u0628\u064f) at end of line $\\rightarrow$ Kitaboo (\u0643\u0650\u062a\u064e\u0627\u0628\u064f\u0648). -   Bihi (\u0628\u0650\u0647\u0650) $\\rightarrow$ Bihee (\u0628\u0650\u0647\u0650\u064a).</p>"},{"location":"theory/writing/#rules-of-omission","title":"Rules of Omission (\u0645\u0627 \u064a\u064f\u062d\u0652\u0630\u064e\u0641)","text":"<p>Letters that are written but skipped in pronunciation must be removed.</p>"},{"location":"theory/writing/#1-hamzat-al-wasl-connecting-hamza","title":"1. Hamzat al-Wasl (Connecting Hamza)","text":"<p>The Alif at the start of words like <code>al-</code>, <code>ibn</code>, <code>istama\\'a</code> is dropped when preceded by another word. -   Wa-istama\\'a (\u0648\u064e\u0627\u0633\u0652\u062a\u064e\u0645\u064e\u0639\u064e) $\\rightarrow$ Wastama\\'a (\u0648\u064e\u0633\u0652\u062a\u064e\u0645\u064e\u0639\u064e). -   Fi al-bayt (\u0641\u0650\u064a \u0627\u0644\u0652\u0628\u064e\u064a\u0652\u062a) $\\rightarrow$ Fil-bayt (\u0641\u0650\u0644\u0652\u0628\u064e\u064a\u0652\u062a).</p>"},{"location":"theory/writing/#2-lam-shamsiya-solar-lam","title":"2. Lam Shamsiya (Solar Lam)","text":"<p>The \\'L\\' of <code>Al-</code> is dropped if followed by a solar letter (t, th, d, dh, r, z, s, sh, s, d, t, z, l, n), and the solar letter is doubled. -   Ash-Shams (\u0627\u0644\u0634\u0651\u064e\u0645\u0652\u0633) $\\rightarrow$ Ashshams (\u0627\u0634\u0652\u0634\u064e\u0645\u0652\u0633). -   Ar-Rajul (\u0627\u0644\u0631\u0651\u064e\u062c\u064f\u0644) $\\rightarrow$ Arrajul (\u0627\u0631\u0652\u0631\u064e\u062c\u064f\u0644).</p>"},{"location":"theory/writing/#3-iltiqa-al-sakinayn-meeting-of-two-stills","title":"3. Iltiqa\\' al-Sakinayn (Meeting of Two Stills)","text":"<p>If a long vowel ends a word and the next word starts with a Sakin (usually after a dropped Hamzat Wasl), the long vowel is dropped to prevent two Sakins from meeting. -   Fi al-bayt (\u0641\u0650\u064a \u0627\u0644\u0652\u0628\u064e\u064a\u0652\u062a) $\\rightarrow$ Fil-bayt (\u0641\u0650\u0644\u0652\u0628\u064e\u064a\u0652\u062a) (The Ya is dropped). -   Da\\'a al-qawm (\u062f\u064e\u0639\u064e\u0627 \u0627\u0644\u0652\u0642\u064e\u0648\u0652\u0645) $\\rightarrow$ Da\\'al-qawm (\u062f\u064e\u0639\u064e\u0644\u0652\u0642\u064e\u0648\u0652\u0645) (The Alif is dropped). -   Yaghzu al-jaysh (\u064a\u064e\u063a\u0652\u0632\u064f\u0648 \u0627\u0644\u0652\u062c\u064e\u064a\u0652\u0634) $\\rightarrow$ Yaghzul-jaysh (\u064a\u064e\u063a\u0652\u0632\u064f\u0644\u0652\u062c\u064e\u064a\u0652\u0634) (The Waw is dropped).</p>"},{"location":"theory/writing/#how-pyarud-handles-this","title":"How PyArud Handles This","text":"<p>The <code>ArudiConverter</code> class implements these rules using a pipeline of regex replacements and lookaheads.</p> <ol> <li>Normalization: Standardizes text (removes Tatweel).</li> <li>Preprocessing: Applies the <code>CHANGE_LST</code> for words like \"Hatha\". Handles Iltiqa\\' al-Sakinayn.</li> <li>Tokenization: Parses the string into letters.</li> <li>State Machine: Iterates through letters to handle:<ul> <li>Shadda expansion.</li> <li>Tanween conversion.</li> <li>Solar Lam skipping.</li> <li>Hamzat Wasl skipping.</li> </ul> </li> <li>Post-processing: Handles Ashba\\' (saturation) at the end of lines.</li> </ol> <p>You can extend the dictionary of special words using <code>ArudiConverter.register_custom_spelling()</code>.</p>"},{"location":"tutorials/debugging/","title":"Debugging Poetry with PyArud","text":"<p>One of PyArud's strongest features is its granular error reporting. This guide explains how to interpret different error statuses.</p>"},{"location":"tutorials/debugging/#the-4-status-codes","title":"The 4 Status Codes","text":"<p>Every foot analyzed by PyArud has a <code>status</code> field.</p> Status Icon Meaning Action Required <code>ok</code> \u2705 The text perfectly matches the foot pattern (or a valid variation). None. <code>broken</code> \u274c Text exists at this position, but it doesn't match any allowed variation for this meter. Check for typos, missing vowels (Harakat), or incorrect word choice. <code>missing</code> \u2753 The line ended before this foot could be formed. The verse is too short (Majzoo/Mashtoor?) or words are missing. <code>extra_bits</code> \u26a0\ufe0f The line has valid feet, but there are leftover syllables at the end. The verse is too long. Remove extra words."},{"location":"tutorials/debugging/#case-study-the-extra-word","title":"Case Study: The Extra Word","text":"<p>Imagine a student writes a Mutakarib line but adds an extra adjective at the end.</p> <p>Correct: <code>\u0641\u064e\u0639\u064f\u0648\u0644\u064f\u0646\u0652 \u0641\u064e\u0639\u064f\u0648\u0644\u064f\u0646\u0652 \u0641\u064e\u0639\u064f\u0648\u0644\u064f\u0646\u0652 \u0641\u064e\u0639\u064f\u0648\u0644\u064f\u0646\u0652</code> Student: <code>\u0641\u064e\u0639\u064f\u0648\u0644\u064f\u0646\u0652 \u0641\u064e\u0639\u064f\u0648\u0644\u064f\u0646\u0652 \u0641\u064e\u0639\u064f\u0648\u0644\u064f\u0646\u0652 \u0641\u064e\u0639\u064f\u0648\u0644\u064f\u0646\u0652 \u0643\u064e\u0628\u0650\u064a\u0631\u0652</code> (Added 'Kabir')</p> <pre><code>result = processor.process_poem([(..., ...)], meter_name=\"mutakareb\")\nlast_foot = result['verses'][0]['sadr_analysis'][-1]\n\nif last_foot['status'] == 'extra_bits':\n    print(f\"Warning: You have extra text: {last_foot['actual_segment']}\")\n</code></pre>"},{"location":"tutorials/debugging/#case-study-the-missing-foot","title":"Case Study: The Missing Foot","text":"<p>If a line is significantly shorter than expected for the meter (e.g., a Tam (full) meter used as Majzoo (shortened)), PyArud will report <code>missing</code> feet.</p> <pre><code># Using a Majzoo line but checking against full Kamil\nresult = processor.process_poem([(majzoo_line, ...)], meter_name=\"kamel\")\n</code></pre> <p>The last one or two feet will show as <code>status: \"missing\"</code>. This is often a hint that the poem might actually be Kamel Majzoo instead of Kamel Tam.</p>"},{"location":"tutorials/debugging/#visualizing-errors","title":"Visualizing Errors","text":"<p>When building a UI for PyArud, you can use these statuses to color-code the text: - Green highlight for <code>ok</code>. - Red underline for <code>broken</code>. - Grey ghost text for <code>missing</code>. - Yellow highlight for <code>extra_bits</code>.</p>"},{"location":"tutorials/first_analysis/","title":"Step-by-Step Analysis Tutorial","text":"<p>In this tutorial, we will manually walk through the process of analyzing a verse, breaking it, and understanding how PyArud \"sees\" the poem.</p>"},{"location":"tutorials/first_analysis/#the-verse","title":"The Verse","text":"<p>We will use a famous line from Al-Mutanabbi (Meter: Basit):</p> <p>\u0623\u064e\u0646\u064e\u0627\u0645\u064f \u0645\u0650\u0644\u0652\u0621\u064e \u062c\u064f\u0641\u064f\u0648\u0646\u0650\u064a \u0639\u064e\u0646\u0652 \u0634\u064e\u0648\u064e\u0627\u0631\u0650\u062f\u0650\u0647\u064e\u0627 ... \u0648\u064e\u064a\u064e\u0633\u0652\u0647\u064e\u0631\u064f \u0627\u0644\u0652\u062e\u064e\u0644\u0652\u0642\u064f \u062c\u064e\u0631\u0651\u064e\u0627\u0647\u064e\u0627 \u0648\u064e\u064a\u064e\u062e\u0652\u062a\u064e\u0635\u0650\u0645\u064f</p> <p>(I sleep with my eyelids full, ignoring its stray thoughts ... while the people stay awake because of them, arguing)</p>"},{"location":"tutorials/first_analysis/#step-1-the-arudi-conversion","title":"Step 1: The Arudi Conversion","text":"<p>Before looking for patterns, we must convert \"Written Arabic\" to \"Spoken Arabic\" (Arudi style).</p> <pre><code>from pyarud.arudi import ArudiConverter\n\nconverter = ArudiConverter()\nsadr = \"\u0623\u064e\u0646\u064e\u0627\u0645\u064f \u0645\u0650\u0644\u0652\u0621\u064e \u062c\u064f\u0641\u064f\u0648\u0646\u0650\u064a \u0639\u064e\u0646\u0652 \u0634\u064e\u0648\u064e\u0627\u0631\u0650\u062f\u0650\u0647\u064e\u0627\"\n\narudi_text, pattern = converter.prepare_text(sadr)\n\nprint(f\"Arudi Text: {arudi_text}\")\nprint(f\"Pattern:    {pattern}\")\n</code></pre> <p>Output: - Arudi Text: <code>\u0623\u0646\u0627\u0645 \u0645\u0644\u0621 \u062c\u0641\u0648\u0646\u064a \u0639\u0646 \u0634\u0648\u0627\u0631\u062f\u0647\u0627</code> (Notice: letters pronounced but not written are added, and vice versa. Here, it's mostly straight forward). - Pattern: <code>11011011101010110110</code></p>"},{"location":"tutorials/first_analysis/#step-2-identifying-the-meter","title":"Step 2: Identifying the Meter","text":"<p>The pattern starts with <code>1101</code> (<code>Fa'ilun</code>) or <code>1010</code> (<code>Mustaf'ilun</code> via Khaban?).</p> <p>Let's run it through the processor.</p> <pre><code>from pyarud.processor import ArudhProcessor\n\nprocessor = ArudhProcessor()\nverse = [\n    (\"\u0623\u064e\u0646\u064e\u0627\u0645\u064f \u0645\u0650\u0644\u0652\u0621\u064e \u062c\u064f\u0641\u064f\u0648\u0646\u0650\u064a \u0639\u064e\u0646\u0652 \u0634\u064e\u0648\u064e\u0627\u0631\u0650\u062f\u0650\u0647\u064e\u0627\", \"\u0648\u064e\u064a\u064e\u0633\u0652\u0647\u064e\u0631\u064f \u0627\u0644\u0652\u062e\u064e\u0644\u0652\u0642\u064f \u062c\u064e\u0631\u0651\u064e\u0627\u0647\u064e\u0627 \u0648\u064e\u064a\u064e\u062e\u0652\u062a\u064e\u0635\u0650\u0645\u064f\")\n]\n\nresult = processor.process_poem(verse)\nprint(result['meter'])\n</code></pre> <p>Output: <code>baseet</code></p>"},{"location":"tutorials/first_analysis/#step-3-introducing-a-defect","title":"Step 3: Introducing a Defect","text":"<p>Let's intentionally break the rhythm to see how PyArud handles it. We will remove the word \"\u0645\u0644\u0621\" (mil'a) from the first hemistich.</p> <p>Broken Sadr: <code>\u0623\u064e\u0646\u064e\u0627\u0645\u064f \u062c\u064f\u0641\u064f\u0648\u0646\u0650\u064a \u0639\u064e\u0646\u0652 \u0634\u064e\u0648\u064e\u0627\u0631\u0650\u062f\u0650\u0647\u064e\u0627</code></p> <pre><code>broken_verse = [\n    (\"\u0623\u064e\u0646\u064e\u0627\u0645\u064f \u062c\u064f\u0641\u064f\u0648\u0646\u0650\u064a \u0639\u064e\u0646\u0652 \u0634\u064e\u0648\u064e\u0627\u0631\u0650\u062f\u0650\u0647\u064e\u0627\", \"\u0648\u064e\u064a\u064e\u0633\u0652\u0647\u064e\u0631\u064f \u0627\u0644\u0652\u062e\u064e\u0644\u0652\u0642\u064f \u062c\u064e\u0631\u0651\u064e\u0627\u0647\u064e\u0627 \u0648\u064e\u064a\u064e\u062e\u0652\u062a\u064e\u0635\u0650\u0645\u064f\")\n]\n\n# Force 'baseet' because we know what it SHOULD be\nresult = processor.process_poem(broken_verse, meter_name=\"baseet\")\n\n# Inspect the Sadr\nsadr_feet = result['verses'][0]['sadr_analysis']\nfor foot in sadr_feet:\n    print(f\"Expected: {foot['expected_pattern']:&lt;10} | Got: {foot['actual_segment']:&lt;10} | Status: {foot['status']}\")\n</code></pre> <p>Output Analysis: 1.  Foot 1: <code>Mustaf'ilun</code> (1010110). Our text <code>\u0623\u064e\u0646\u064e\u0627\u0645\u064f \u062c\u064f</code> (A-na-mu-ju) -&gt; <code>11011</code>. This doesn't match well. 2.  PyArud will try to find the best match. It might flag the first foot as broken, or \"eat\" the wrong characters.</p> <p>By forcing the meter (<code>meter_name=\"baseet\"</code>), you tell PyArud: \"I expect this structure. Tell me where the text deviates.\" This is powerful for educational tools or auto-correct features.</p>"}]}